###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.30.2.51295/W32 for ARM     31/Mar/2014  10:27:56 #
# Copyright 1999-2009 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\work\T6\FW\src\App\app.c                              #
#    Command line =  D:\work\T6\FW\src\App\app.c -lcN                         #
#                    D:\work\T6\FW\src\Project\EWARMv5\Debug\List\ -o         #
#                    D:\work\T6\FW\src\Project\EWARMv5\Debug\Obj\ --no_cse    #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    5.4\arm\INC\DLib_Config_Full.h" -I                       #
#                    D:\work\T6\FW\src\Project\EWARMv5\..\ -I                 #
#                    D:\work\T6\FW\src\Project\EWARMv5\..\..\App\ -I          #
#                    D:\work\T6\FW\src\Project\EWARMv5\..\..\Drivers\ -I      #
#                    D:\work\T6\FW\src\Project\EWARMv5\..\..\FatFs\ -I        #
#                    D:\work\T6\FW\src\Project\EWARMv5\..\..\Lib\inc\ -I      #
#                    D:\work\T6\FW\src\Project\EWARMv5\..\..\uCOS\uC-CPU\ -I  #
#                    D:\work\T6\FW\src\Project\EWARMv5\..\..\uCOS\uC-LIB\ -I  #
#                    D:\work\T6\FW\src\Project\EWARMv5\..\..\uCOS\uCOS-II\Por #
#                    ts\ -I D:\work\T6\FW\src\Project\EWARMv5\..\..\uCOS\uCOS #
#                    -II\Source\ -I D:\work\T6\FW\src\Project\EWARMv5\..\..\u #
#                    COS\uC-Probe\ -I D:\work\T6\FW\src\Project\EWARMv5\..\.. #
#                    \usb_lib\ -I "C:\Program Files\IAR Systems\Embedded      #
#                    Workbench 5.4\arm\INC\" -Ol                              #
#    List file    =  D:\work\T6\FW\src\Project\EWARMv5\Debug\List\app.lst     #
#    Object file  =  D:\work\T6\FW\src\Project\EWARMv5\Debug\Obj\app.o        #
#                                                                             #
#                                                                             #
###############################################################################

D:\work\T6\FW\src\App\app.c
      1          /**
      2          * @file app.c
      3          * @brief 2.4GPOS项目应用主程序
      4          *
      5          * @version V0.0.1
      6          * @author joe
      7          * @date 2010年04月28日
      8          * @note
      9          *		参考《中国移动手机支付业务现场脱机支付POS终端 规范_v1.0.0.doc》
     10          * 
     11          * @copy
     12          *
     13          * 此代码为深圳江波龙电子有限公司项目代码，任何人及公司未经许可不得复制传播，或用于
     14          * 本公司以外的项目。本司保留一切追究权利。
     15          *
     16          * <h1><center>&copy; COPYRIGHT 2010 netcom</center></h1>
     17          */
     18          
     19          /* Private include -----------------------------------------------------------*/
     20          #include "app.h"
     21          #include "Dialog.h"
     22          #include <string.h>
     23          #include <stdlib.h>
     24          #include "stm32f10x_lib.h"
     25          #include "ucos_ii.h"
     26          #include <stdio.h>
     27          #include "lcd.h"
     28          #include "data_uart.h"
     29          #include "gui.h"
     30          #include "pic.h"
     31          #include "Terminal_Para.h"
     32          #include "calendar.h"
     33          #include "dlg.h"
     34          #include "basic_fun.h"
     35          #include "timeBase.h"
     36          #include "usb_pwr.h"
     37          #include "usb_istr.h"
     38          #include "usb_lib.h"
     39          #include "usb_prop.h"
     40          #include "PCUsart.h"
     41          #include "power_detect.h"
     42          #include "JMemory.h"
     43          #include "ff.h"
     44          #include "uE988_scan.h"
     45          #include "YFBT07.h"
     46          #include "data_transfer.h"
     47          
     48          const unsigned char *app_ver="V1.0.1";		//应用版本号
     49          
     50          static unsigned char	BarCode[31];				//检测条形码的后台任务与前台之间传递条形码的变量
     51          static unsigned char	last_BarCode[31];			//上次获取到的条形码
     52          static unsigned char	BarCode_Type[20];			//条码类型
     53          static unsigned char	BarCode_Len;				//条码长度
     54          static unsigned char	dlg_refresh_flag;	//窗体强制刷新的标记
     55          static unsigned int		barcode_got_flag;				//获取到条形码的标记
     56          static int				current_home_item;
     57          static unsigned char	scan_func_state;	
     58          static unsigned char	valid_barcode_start_offset_tmp;
     59          static unsigned char	valid_barcode_end_offset_tmp;
     60          static unsigned char	line3_save[21];
     61          static unsigned char	tmp_op_timeout;	
     62          static unsigned char	special_func_flag;
     63          
     64          //static TCHECK_INFO_RECORD	check_info;
     65          static TCHECK_INFO_RECORD	*p_check_info;
     66          static TGOODS_SPEC_RECORD   *p_goods_node;	
     67          static int					searched_rec_index;		//搜索到的记录索引
     68          
     69          typedef struct tag_chk_info_context
     70          {
     71          	TCHECK_INFO_RECORD	check_info_node;			//盘点信息
     72          	TGOODS_SPEC_RECORD	goods_node;					//商品信息
     73          	unsigned int		chk_info_index;				//盘点信息在其清单中的位置索引
     74          	unsigned int		goods_info_index;			//商品信息在其清单中的位置索引
     75          	unsigned int		chkinf_need_update_flag;	//当前条码的盘点信息是否需要更新的标记
     76          	int					add_value;					//当前条码的盘点数量的累加值
     77          }CHK_INFO_CONTEXT;
     78          
     79          static	CHK_INFO_CONTEXT			op_context;		//对条码进行盘点时的上下文环境	
     80          static	unsigned int	send_num;
     81          
     82          
     83          unsigned char			need_refresh_signal;			//需要刷新无线信号强度的标记
     84          unsigned char			no_update_icon_flg;
     85          unsigned char			task_exit_flag;
     86          unsigned char			usb_cable_state;
     87          unsigned char			need_refresh_edit_index_tbl[4];	//需要刷新的编辑框列表
     88          unsigned int					scan_start;						//开始扫描的标记
     89          
     90          extern TDialog					g_dlg;
     91          extern unsigned char			g_editValue[MAX_EDIT][MAX_EDITNUM];//编辑框的全局变量
     92          extern unsigned char			menu_current_item;			//当前菜单项
     93          extern unsigned char			menu_start;
     94          extern unsigned char			max_dlg;
     95          extern unsigned char			next_dlg_id;
     96          extern	TTerminalPara			g_param;							//Terminal Param
     97          //extern TDRAW_ITEM				draw_content[];
     98          extern unsigned char			gFontSize;			// 字号
     99          extern unsigned char			display_menu_item_array[5];
    100          extern int						bluetooth_module_state;
    101          extern FIL						file2;
    102          extern int						bluetooth_match_cmd_cnt;
    103          extern int						bluetooth_state_cnt;
    104          extern TypedefDateTime       currentDateTime;	
    105          extern unsigned char			data_trans_state;				//数据导入导出时的状态
    106          extern unsigned char			update_icon_cnt;
    107          extern unsigned int				vcom_device_state;
    108          /* Private typedef -----------------------------------------------------------*/
    109          /* Private define ------------------------------------------------------------*/
    110          /* Private macro -------------------------------------------------------------*/
    111          /* Private variables ---------------------------------------------------------*/
    112          /* Private function prototypes -----------------------------------------------*/
    113          /* Private functions ---------------------------------------------------------*/
    114          
    115          
    116          ////////////////////////////用于工厂测试程序///////////////////////////////////
    117          #define  KEY_COUNT   10 //按键总数目
    118          /**
    119          *@brief 按键扫描时定义每个按键在屏幕上的显示位置及其按键名在屏幕上的宽度信息
    120          */
    121          typedef struct  {
    122          	unsigned char key;
    123          	unsigned char x;
    124          	unsigned char y;
    125          	unsigned char width;
    126          	int		      clear_flag;		//是否已经扫描
    127          } Tkeyscan_pos_width;
    128          
    129          static int factory_test_task(int param1, int param2, void *param3, void *param4);
    130          static unsigned char dlgproc_test_proc(unsigned char *key);
    131          static int scan_aging_task(int param1, int param2, void *param3, void *param4);
    132          
    133          static void test_LCD_display(void);
    134          static void testKeypad(void);//按键测试
    135          static void testScanerInit(void);//扫描头测试
    136          static void testBluetooth(void);//蓝牙测试
    137          static void testUSB(void);//USB测试
    138          static void testRTC(void);//rtc测试
    139          static void testAD(void);
    140          
    141          typedef void (*testfunc)(void);		//定义测试函数指针
    142          typedef	void (*pFunction)(void);
    143          
    144          const  testfunc testfunc_tbl[] = {
    145          	test_LCD_display,			//测试显示
    146          	testKeypad,					//测试键盘
    147          	testScanerInit,				//测试扫描头
    148          	testUSB,					//USB测试
    149          	testRTC,					//RTC测试
    150          	testAD,				    //AD采样测试
    151          	testBluetooth				//测试蓝牙模块
    152          };
    153          
    154          
    155          /**
    156          * @brief 这个表格是测试按键扫描时，按键在屏幕上的显示位置相对应的
    157          * @see	每个按键在扫描时，对应按键名在屏幕上的显示如下：
    158          POWER 
    159           -  ESC ENTER  -
    160          LEFT UP RIGHT DOWN
    161                SCAN
    162          */
    163          static Tkeyscan_pos_width keyscan_pos_width_tbl[] =
    164          {
    165          	{KEY_POWER,0,0,5,1},
    166          	{KEY_LEFT_SHOTCUT,0,13,4,1},{KEY_ESC,6*4,13,4,1},{KEY_ENTER,6*8,13,6,1},{KEY_RIGHT_SHOTCUT,6*14,13,3,1},
    167          	{KEY_LEFT,0,13*2,5,1},{KEY_UP,6*5,13*2,3,1},{KEY_RIGHT,6*8,13*2,6,1},{KEY_DOWN,6*14,13*2,4,1},
    168          	{KEY_SCAN,6*6,13*3,4,1},
    169          
    170          	{0xff,0,0,0,0}//表的结束标记
    171          };
    172          
    173          static int						testproc_first_enterkey;//测试程序里，按一次测试按键的标记
    174          static  unsigned char			enter_scaner_test_flag;//进入扫描测试的标志
    175          
    176          /**
    177          ***************************************************************************
    178          *@brief 后台检测条形码的任务
    179          *@param[in] int param1  指明是否受系统设置的条码位数的规则限制  0：受  1：不受
    180          *@note 
    181          ***************************************************************************
    182          */
    183          static int ScanBarCode_task(int param1, int param2, void *param3, void *param4)
    184          {
    185          	int								command;
    186          	unsigned char					tmp[32],len;
    187          	while(1)
    188          	{
    189          		if (0 == task_read_command_from_ui(&command,0))
    190          		{
    191          			if (TASK_EXIT == command)
    192          			{
    193          				if (barcode_got_flag)
    194          				{
    195          					//已经有条形码检测到或者输入了,跳转到询问是否需要更新库存信息的界面
    196          					return KEY_EXT_2;
    197          				}
    198          				else
    199          				{
    200          					//还没有条形码检测到或者输入过，那么直接返回到主界面
    201          					return KEY_EXT_3;
    202          				}
    203          			}
    204          
    205          			if (TASK_RUN == command)
    206          			{
    207          				//用户按了扫描键
    208          				//开始扫描商品条形码
    209          				//scan_start = 1;
    210          				memset(BarCode,0,31);
    211          				memset(tmp,0,31);
    212          				memset(BarCode_Type,0,20);
    213          				BarCode_Len = 0;
    214          				if (UE988_get_barcode(BarCode_Type, tmp,30, &BarCode_Len) == 0)
    215          				//if (scanner_get_barcode(tmp,30,BarCode_Type,&BarCode_Len)  == 0)
    216          				{
    217          					//获取到条码
    218          					//led_r_ctrl(1);
    219          					Delay(5000);
    220          					Beep(BEEP_DELAY);
    221          					//led_r_ctrl(0);
    222          					barcode_got_flag = 1;
    223          				}
    224          				//else
    225          				//{
    226          				//	//获取条形码失败
    227          				//	//不需要处理，也不需要通知用户，就当做没有扫描到条码
    228          
    229          				//	task_send_command_to_ui(KEY_EXT_1);
    230          				//}
    231          
    232          				if (param1 == 0)
    233          				{
    234          					//表示需要根据系统设置的录入条码位数来返回获取到的条码
    235          					if ((g_param.valid_barcode_start_offset == 0xff)&&(g_param.valid_barcode_end_offset == 0xff))
    236          					{
    237          						memcpy(BarCode,tmp,BarCode_Len);
    238          					}
    239          					else
    240          					{
    241          						if ((g_param.valid_barcode_start_offset < 30)&&(g_param.valid_barcode_end_offset <= 30)&&(g_param.valid_barcode_start_offset < g_param.valid_barcode_end_offset)&&(g_param.valid_barcode_start_offset < BarCode_Len))
    242          						{
    243          							len = g_param.valid_barcode_end_offset - g_param.valid_barcode_start_offset;
    244          							if (len > (BarCode_Len - g_param.valid_barcode_start_offset))
    245          							{
    246          								len = BarCode_Len - g_param.valid_barcode_start_offset;
    247          							}
    248          							memcpy(BarCode,tmp+g_param.valid_barcode_start_offset-1,len+1);
    249          						}
    250          						else
    251          						{
    252          							memcpy(BarCode,tmp,BarCode_Len);
    253          						}
    254          
    255          					}
    256          
    257          				}
    258          				else
    259          				{
    260          					memcpy(BarCode,tmp,BarCode_Len);
    261          				}
    262          
    263          				task_send_command_to_ui(KEY_EXT_1);
    264          				//scan_start = 0;
    265          
    266          				//模拟  
    267          				//OSTimeDlyHMSM(0,0,0,10);
    268          				//strcpy((char*)BarCode,"123456789123");
    269          				//task_send_command_to_ui(KEY_EXT_1);
    270          			}
    271          
    272          		}
    273          		OSTimeDlyHMSM(0, 0, 0, 300);
    274          	}
    275          }
    276          
    277          /**
    278          * @brief 检查输入的时间格式是否合法
    279          * @note  输入的时间格式是YYYYMMDDHHMMSS
    280          * return  0: 合法
    281          *        -1: 非法
    282          */
    283          static int check_time(unsigned char * input)
    284          {
    285          	unsigned short year,month,date,temp;
    286          	year = ((*input)- 0x30)*1000 + (*(input + 1) - 0x30)*100 + (*(input + 2) - 0x30)*10 + (*(input + 3) - 0x30);
    287          
    288          	if (year < 2000 ||year > 2030)//不允许输入2000~2030之外的数据
    289          	{
    290          		return -1;
    291          	}
    292          
    293          	//检查输入月份的合法性
    294          	month = (*(input + 4) - 0x30)*10 + (*(input + 5) - 0x30);		//将月份转换为10进制
    295          	if ((month > 12)||(month == 0))
    296          	{
    297          		return -1;
    298          	}
    299          
    300          	//检查输入日期的合法性
    301          	date = (*(input + 6) - 0x30)*10 + (*(input + 7) - 0x30);		//将日期转换为10进制
    302          	//月大，31天
    303          	if ((month == 1)||(month == 3)||(month == 5) ||(month == 7) ||(month == 8) ||(month == 10) ||(month == 12))  
    304          	{
    305          		if ((date > 31)||(date == 0)) 
    306          		{
    307          			return -1;
    308          		}
    309          	}
    310          	//2月份
    311          	else if (month == 2) 
    312          	{
    313          		if ((year%4==0 && year%100!=0) || (year%400==0))		//闰年
    314          		{
    315          			if ((date > 29)||(date == 0)) 
    316          			{
    317          				return -1;
    318          			}
    319          		}
    320          		else
    321          		{
    322          			if ((date > 28)||(date == 0)) 
    323          			{
    324          				return -1;
    325          			}
    326          		}
    327          	}
    328          	//月小
    329          	else
    330          	{
    331          		if ((date > 30)||(date == 0)) 
    332          		{
    333          			return -1;
    334          		}
    335          	}
    336          
    337          
    338          	//检查输入小时的合法性
    339          	temp = (*(input + 8) - 0x30)*10 + (*(input + 9) - 0x30);		//将小时转换为10进制
    340          	if (temp > 23) 
    341          	{
    342          		return -1;
    343          	}
    344          	//检查输入分钟的合法性
    345          	temp = (*(input + 10) - 0x30)*10 + (*(input + 11) - 0x30);		//将分钟转换为10进制
    346          	if (temp > 59) 
    347          	{
    348          		return -1;
    349          	}
    350          	//检查输入秒数的合法性
    351          	temp = (*(input + 12) - 0x30)*10 + (*(input + 13) - 0x30);		//将秒数转换为10进制
    352          	if (temp > 59) 
    353          	{
    354          		return -1;
    355          	}
    356          
    357          	//合法的输入,将用户输入的时间更新到当前时间里面
    358          	currentDateTime.year = (unsigned char)(year - 2000);
    359          	currentDateTime.month = (unsigned char)month;
    360          	currentDateTime.day = (unsigned char)date;
    361          	currentDateTime.hour = (*(input + 8) - 0x30)*10 + (*(input + 9) - 0x30);
    362          	currentDateTime.min = (*(input + 10) - 0x30)*10 + (*(input + 11) - 0x30); 
    363          	currentDateTime.sec = (*(input + 12) - 0x30)*10 + (*(input + 13) - 0x30); 
    364          	return 0;		
    365          }
    366          
    367          
    368          static void refresh_home_item(void)
    369          {
    370          	gui_FillRect(0,16,GUI_WIDTH,24,BG_COLOR,0);
    371          	switch (current_home_item)
    372          	{
    373          	case 1:
    374          		gui_PictureOut(36,16,PIC_SCAN,0);
    375          		if (g_param.language == LANG_ENGLISH)
    376          		{
    377          			gui_TextOut_ext(CENTER_ALIGN,42,"  Scan  ",1,0);
    378          		}
    379          		else
    380          		{
    381          			gui_TextOut_ext(CENTER_ALIGN,42,"  扫描  ",1,0);
    382          		}
    383          		break;
    384          	case 2:
    385          		gui_PictureOut(36,16,PIC_TRANS,0);
    386          		if (g_param.language == LANG_ENGLISH)
    387          		{
    388          			gui_TextOut_ext(CENTER_ALIGN,42,"Transfer",1,0);
    389          		}
    390          		else
    391          		{
    392          			gui_TextOut_ext(CENTER_ALIGN,42,"数据传输",1,0);
    393          		}
    394          		break;
    395          	case 3:
    396          		gui_PictureOut(36,16,PIC_SETTING,0);
    397          		if (g_param.language == LANG_ENGLISH)
    398          		{
    399          			gui_TextOut_ext(CENTER_ALIGN,42,"Setting",1,0);
    400          		}
    401          		else
    402          		{
    403          			gui_TextOut_ext(CENTER_ALIGN,42,"系统设置",1,0);
    404          		}
    405          		break;
    406          	case 4:
    407          		gui_PictureOut(36,16,PIC_INFO,0);
    408          		if (g_param.language == LANG_ENGLISH)
    409          		{
    410          			gui_TextOut_ext(CENTER_ALIGN,42,"  Info  ",1,0);
    411          		}
    412          		else
    413          		{
    414          			gui_TextOut_ext(CENTER_ALIGN,42,"系统信息",1,0);
    415          		}
    416          		break;
    417          	default:
    418          		break;
    419          	}
    420          
    421          	gui_refresh(0,0,LCD_WIDTH,LCD_HEIGHT);
    422          }
    423          
    424          /**
    425          * @brief 主界面回调函数，task_ui第一个运行起来的界面回调函数
    426          */
    427          static unsigned char dlgproc_logo(unsigned char type,unsigned char *key)
    428          {
    429          	if (DLGCB_DRAW == type)
    430          	{
    431          		special_func_flag = 0;
    432          		refresh_home_item();
    433          		//gui_PictureOut(36,16,PIC_SCAN+(current_home_item-1),1);
    434          		//gui_PictureOut(118,ICON_HEIGHT+4,PIC_UP,1);
    435          		//gui_PictureOut(118,ICON_HEIGHT+1+26,PIC_DOWN,1);
    436          	}
    437          
    438          	if (DLGCB_RUN == type)
    439          	{
    440          		if (*key == KEY_UP || *key == KEY_DOWN)
    441          		{
    442          			if (*key == KEY_UP)
    443          			{
    444          				if (current_home_item == 1)
    445          				{
    446          					current_home_item = 4;
    447          				}
    448          				else
    449          				{
    450          					current_home_item--;
    451          				}
    452          			}
    453          			else
    454          			{
    455          				if (current_home_item == 4)
    456          				{
    457          					current_home_item = 1;
    458          				}
    459          				else
    460          				{
    461          					current_home_item++;
    462          				}
    463          			}
    464          
    465          			refresh_home_item();
    466          			return RUN_RERUN;
    467          		}
    468          
    469          		if (*key == KEY_LEFT_SHOTCUT || *key == KEY_ENTER || *key == KEY_SCAN)
    470          		{
    471          			*key = KEY_EXT_1 + current_home_item - 1;
    472          			return RUN_NEXT;
    473          		}
    474          
    475          		//输入特殊按键序列: "KEY_ESC、LEFT、KEY_ESC、LEFT、KEY_ESC、LEFT、KEY_ESC" 进入隐藏功能菜单
    476          		if ((KEY_ESC == *key)&&(special_func_flag == 0))
    477          		{
    478          			special_func_flag = 1;
    479          			return RUN_RERUN;
    480          		}
    481          
    482          		if (1 == special_func_flag)
    483          		{	
    484          			if ( KEY_LEFT == *key)
    485          			{
    486          				special_func_flag = 2;
    487          			}
    488          			else
    489          			{
    490          				special_func_flag = 0;
    491          			}
    492          			return RUN_RERUN;
    493          		}
    494          
    495          		if (2 == special_func_flag)
    496          		{	
    497          			if ( KEY_ESC == *key)
    498          			{
    499          				special_func_flag = 3;
    500          			}
    501          			else
    502          			{
    503          				special_func_flag = 0;
    504          			}
    505          			return RUN_RERUN;
    506          		}
    507          
    508          		if (3 == special_func_flag)
    509          		{	
    510          			if ( KEY_LEFT == *key)
    511          			{
    512          				special_func_flag = 4;
    513          			}
    514          			else
    515          			{
    516          				special_func_flag = 0;
    517          			}
    518          			return RUN_RERUN;
    519          		}
    520          
    521          		if (4 == special_func_flag)
    522          		{	
    523          			if ( KEY_ESC == *key)
    524          			{
    525          				special_func_flag = 5;
    526          			}
    527          			else
    528          			{
    529          				special_func_flag = 0;
    530          			}
    531          			return RUN_RERUN;
    532          		}
    533          
    534          		if (5 == special_func_flag)
    535          		{	
    536          			if ( KEY_LEFT == *key)
    537          			{
    538          				special_func_flag = 6;
    539          			}
    540          			else
    541          			{
    542          				special_func_flag = 0;
    543          			}
    544          			return RUN_RERUN;
    545          		}
    546          
    547          		if (6 == special_func_flag)
    548          		{	
    549          			if ( KEY_ESC == *key)
    550          			{
    551          				*key = KEY_EXT_9;
    552          				return RUN_NEXT;
    553          			}
    554          			else
    555          			{
    556          				special_func_flag = 0;
    557          			}
    558          			return RUN_RERUN;
    559          		}
    560          		
    561          	}
    562          	return RUN_CONTINUE;
    563          }
    564          
    565          
    566          //构造传输的字符串
    567          static void build_transfer_str(TCHECK_INFO_RECORD * p_check,unsigned int num,unsigned char *str)
    568          {
    569          	unsigned char  temp[20];
    570          	//构造传输的字符串
    571          	strcpy(str,p_check->bar_code);
    572          	if (g_param.add_time_option || g_param.add_date_option)
    573          	{
    574          		build_time_dis_str(p_check->check_time,temp,0);
    575          		
    576          		if (g_param.add_date_option)
    577          		{
    578          			strcat(str,g_param.transfer_seperator);
    579          			strcat(str,temp);
    580          			str[strlen(str) - 9] = 0;
    581          		}
    582          
    583          		if (g_param.add_time_option)
    584          		{
    585          			strcat(str,g_param.transfer_seperator);
    586          			strcat(str,temp+11);
    587          		}
    588          	}
    589          
    590          	if (g_param.quantity_enter_mode == QUANTITY_ENTER_MODE_NUM)
    591          	{
    592          		strcat(str,g_param.transfer_seperator);
    593          		sprintf(temp,"%d",num);
    594          		strcat(str,temp);
    595          	}
    596          
    597          	strcat(str,"\x0d\x0a");		//换行符
    598          }
    599          
    600          //检测当前传输连接的状态
    601          //0:断开状态
    602          //1:连接状态
    603          static int check_link_state(unsigned char transfer_mode)
    604          {
    605          	if (transfer_mode == TRANSFER_MODE_BLUETOOTH)
    606          	{
    607          		return YFBT07_Connect_state();
    608          	}
    609          	else if (transfer_mode == TRANSFER_MODE_KEYBOARD || transfer_mode == TRANSFER_MODE_VIRTUAL_COMM)
    610          	{
    611          		if (bDeviceState == CONFIGURED)
    612          		{
    613          			return 1;
    614          		}
    615          
    616          		return 0;
    617          	}
    618          	else if (transfer_mode == TRANSFER_MODE_U_DISK)
    619          	{
    620          		//U DISK存储方式时，如果没有指定存储的目标文件，认为连接状态断开
    621          		if (g_param.u_disk_storage_file[0] == 0)
    622          		{
    623          			return 0;
    624          		}
    625          
    626          		if (f_open(&file2,g_param.u_disk_storage_file,FA_OPEN_EXISTING | FA_READ | FA_WRITE) != FR_OK)
    627          		{
    628          			return 0;
    629          		}
    630          
    631          		if (file2.fsize > 1024*1024)
    632          		{
    633          			return 0;	//如果目标文件太大也认为连接状态是断开的
    634          		}
    635          		return 1;
    636          	}
    637          	else
    638          	{
    639          		//脱机存储方式时，如果脱机存储的记录达到上限了，认为连接状态断开
    640          		if (record_module_count(REC_TYPE_BATCH) == CHECK_LIST_MAX_CNT)
    641          		{
    642          			return 0;
    643          		}
    644          
    645          		return 1;
    646          	}
    647          }
    648          
    649          //脱机保存传输的字符串
    650          static int batch_save_barcode_str(unsigned char *str)
    651          {
    652          	TBATCH_NODE  batch_node;
    653          
    654          	if (g_param.transfer_mode == TRANSFER_MODE_BLUETOOTH && g_param.bluetooth_transfer_option == 0)
    655          	{
    656          		//蓝牙传输离线脱机保存选项关闭时，不保存
    657          		return 0;
    658          	}
    659          
    660          	memset((void*)&batch_node,0,sizeof(TBATCH_NODE));
    661          	strcpy(batch_node.batch_str,str);
    662          	if(record_add(REC_TYPE_BATCH,(unsigned char*)&batch_node))
    663          	{
    664          		OSTimeDlyHMSM(0,0,0,200);
    665          		if(record_add(REC_TYPE_BATCH,(unsigned char*)&batch_node))
    666          		{
    667          			return -1;
    668          		}
    669          	}
    670          
    671          	return 0;
    672          }
    673          
    674          //传输一次字符串
    675          static int transfer_barcode_str(unsigned char *str,unsigned char transfer_mode)
    676          {
    677          	TBATCH_NODE  batch_node;
    678          	int			i,cnt;
    679          	unsigned char key_value_report[8];
    680          
    681          	if (transfer_mode == TRANSFER_MODE_BLUETOOTH)
    682          	{
    683          		YFBT07_SendKey(str,strlen(str));
    684          	}
    685          	else if (transfer_mode == TRANSFER_MODE_KEYBOARD)
    686          	{
    687          		OSSchedLock();
    688          		for (i = 0; i < (strlen(str)-1); i++)
    689          		{
    690          			ascii_to_keyreport(str[i],key_value_report);
    691          
    692          			SendData_To_PC(key_value_report, 3);
    693          			SendData_To_PC("\x00\x00\x00", 3);
    694          		}
    695          
    696          		//memcpy(key_value_report,"\x00\x00\x28",3);	//换行
    697          
    698          		//SendData_To_PC(key_value_report, 3);
    699          		//SendData_To_PC("\x00\x00\x00", 3);	//弹起
    700          		OSSchedUnlock();
    701          	}
    702          	else if(transfer_mode == TRANSFER_MODE_VIRTUAL_COMM)
    703          	{
    704          		SendData_To_PC(str,strlen(str));
    705          	}
    706          	else if (transfer_mode == TRANSFER_MODE_U_DISK)
    707          	{
    708          		if (f_open(&file2,g_param.u_disk_storage_file,FA_OPEN_EXISTING | FA_READ | FA_WRITE) != FR_OK)
    709          		{
    710          			return -1;
    711          		}
    712          		
    713          		f_lseek(&file2,file2.fsize);	//文件指针移动文件末尾
    714          		
    715          		if (f_write(&file2,(void*)str,strlen(str),&cnt) != FR_OK)
    716          		{
    717          			f_close(&file2);
    718          			return -1;
    719          		}
    720          
    721          		if (cnt != strlen(str))
    722          		{
    723          			f_close(&file2);
    724          			return -1;
    725          		}
    726          
    727          		f_close(&file2);
    728          	}
    729          	else
    730          	{
    731          		//脱机保存的方式
    732          		memset((void*)&batch_node,0,sizeof(TBATCH_NODE));
    733          		strcpy(batch_node.batch_str,str);
    734          		if(record_add(REC_TYPE_BATCH,(unsigned char*)&batch_node))
    735          		{
    736          			OSTimeDlyHMSM(0,0,0,200);
    737          			if(record_add(REC_TYPE_BATCH,(unsigned char*)&batch_node))
    738          			{
    739          				return -1;
    740          			}
    741          		}
    742          	}
    743          
    744          	return 0;
    745          }
    746          
    747          
    748          //传输获取到的条码信息
    749          static int transfer_barcode_proc(TCHECK_INFO_RECORD * p_check,unsigned int num)
    750          {
    751          	unsigned char  str[64];
    752          	
    753          	build_transfer_str(p_check,num,str);
    754          
    755          	if (check_link_state(g_param.transfer_mode) == 0)
    756          	{
    757          		//传输连接是断开状态
    758          		Beep(BEEP_DELAY*2);
    759          		if (g_param.quantity_enter_mode == QUANTITY_ENTER_MODE_REPEAT)
    760          		{
    761          			while (num)
    762          			{
    763          				batch_save_barcode_str(str);
    764          				num--;
    765          				OSTimeDlyHMSM(0,0,0,50);
    766          			}
    767          		}
    768          		else
    769          		{
    770          			batch_save_barcode_str(str);
    771          		}
    772          	}
    773          	else
    774          	{
    775          		if (g_param.quantity_enter_mode == QUANTITY_ENTER_MODE_REPEAT)
    776          		{
    777          			while (num)
    778          			{
    779          				transfer_barcode_str(str,g_param.transfer_mode);
    780          				num--;
    781          				OSTimeDlyHMSM(0,0,0,50);
    782          			}
    783          		}
    784          		else
    785          		{
    786          			transfer_barcode_str(str,g_param.transfer_mode);
    787          		}
    788          	}
    789          }
    790          
    791          #define	ERR_TYPE_DUPLICATION	1		//条码重复错误	
    792          #define	ERR_TYPE_OVERALL		2		//条码存储已达上限
    793          #define	ERR_TYPE_STOREFAIL		3		//条码存储失败
    794          
    795          //错误提示
    796          static unsigned char err_tip(unsigned char err_type)
    797          {
    798          	Beep(BEEP_DELAY*2);
    799          	switch (err_type)
    800          	{
    801          	case ERR_TYPE_DUPLICATION:
    802          		if (g_param.language == LANG_ENGLISH)
    803          		{
    804          			gui_TextOut(0,39,"Barcode duplication!",0,0);
    805          			strcpy(line3_save,"Barcode duplication!");
    806          		}
    807          		else
    808          		{
    809          			gui_TextOut(0,39,"条码已存在!",0,0);
    810          			strcpy(line3_save,"条码已存在!");
    811          		}
    812          		break;
    813          	case ERR_TYPE_OVERALL:
    814          		if (g_param.language == LANG_ENGLISH)
    815          		{
    816          			gui_TextOut(0,39,"No More Space",0,0);
    817          		}
    818          		else
    819          		{
    820          			gui_TextOut(0,39,"存储已达上限!",0,0);
    821          		}
    822          		break;
    823          	case ERR_TYPE_STOREFAIL:
    824          		if (g_param.language == LANG_ENGLISH)
    825          		{
    826          			gui_TextOut(0,39,"Record Store fail!",0,0);
    827          		}
    828          		else
    829          		{
    830          			gui_TextOut(0,39,"记录存储失败!",0,0);
    831          		}
    832          		break;
    833          	}
    834          
    835          	gui_refresh(0,0,LCD_WIDTH,LCD_HEIGHT);
    836          	return RUN_RERUN;
    837          }
    838          
    839          
    840          //显示商品规格
    841          int display_goods_spec(void)
    842          {
    843          	int i,j;
    844          
    845          	for (i = 0; i < 5;i++)
    846          	{
    847          		if (op_context.goods_node.spec[i][0] != 0)
    848          		{
    849          			break;
    850          		}
    851          	}
    852          
    853          	if (i == 5)
    854          	{
    855          		return 0;	//没有可以显示的商品规格
    856          	}
    857          
    858          	gui_FillRect(0,0,LCD_WIDTH,LCD_HEIGHT,BG_COLOR,0);
    859          
    860          	for (i = 0,j = 0; i < 5;i++)
    861          	{
    862          		if (op_context.goods_node.spec[i][0] != 0)
    863          		{
    864          			gui_TextOut(0,13*j,op_context.goods_node.spec[i],0,0);
    865          			j++;
    866          		}
    867          	}
    868          
    869          	gui_refresh(0,0,LCD_WIDTH,LCD_HEIGHT);
    870          	no_update_icon_flg = 1;
    871          
    872          	return j;
    873          }
    874          
    875          
    876          /**
    877          * @brief 扫描功能
    878          */
    879          static unsigned char dlgproc_scan_func(unsigned char type,unsigned char *key)
    880          {
    881          	unsigned char  dis_str[13];
    882          	if (DLGCB_CREATE == type)
    883          	{
    884          		if (dlg_refresh_flag == 0)
    885          		{
    886          			if (g_param.database_query_option)
    887          			{
    888          				//如果开启了查询数据库选项，那么需要检查数据库文件是否存在
    889          				if (check_database())
    890          				{
    891          					gui_FillRect(0,0,GUI_WIDTH,GUI_HEIGHT,BG_COLOR,1);
    892          					if (g_param.language == LANG_ENGLISH)
    893          					{
    894          						gui_TextOut_ext(CENTER_ALIGN,20,"Databse isn't exist!",0,1);
    895          					}
    896          					else
    897          					{
    898          						gui_TextOut_ext(CENTER_ALIGN,20,"数据库文件不存在!",0,1);
    899          					}
    900          					OSTimeDlyHMSM(0,0,1,0);
    901          				}
    902          			}
    903          		}
    904          	}
    905          
    906          	if (DLGCB_DRAW == type)
    907          	{
    908          		if (dlg_refresh_flag == 0)
    909          		{
    910          			if (g_param.language == LANG_ENGLISH)
    911          			{
    912          				gui_TextOut(0,26,"Please press\"SCAN\"...",0,1);
    913          			}
    914          			else
    915          			{
    916          				gui_TextOut(0,26,"请按\"SCAN\"键扫描...",0,1);
    917          			}
    918          
    919          			scan_func_state = 0;
    920          			memset((void*)&op_context,0,sizeof(CHK_INFO_CONTEXT));
    921          			memset(last_BarCode,0,31);
    922          			dlg_run_bgtask(ScanBarCode_task,0, 0, 0, 0);	//后台等待检测条形码的任务
    923          		}
    924          		else
    925          		{
    926          			if (strlen(BarCode) > 20)
    927          			{
    928          				gui_TextOut(0,13,BarCode,0,1);
    929          			}
    930          			else
    931          			{
    932          				gui_TextOut(0,26,BarCode,0,1);
    933          			}
    934          
    935          			gui_TextOut(0,39,line3_save,0,1);
    936          
    937          			if (scan_func_state == 2)
    938          			{
    939          				
    940          				if (g_param.language == LANG_ENGLISH)
    941          				{
    942          					sprintf(dis_str,"Esc    Enter% 8d",send_num);
    943          					gui_TextOut(0,GUI_HEIGHT-SHOTCUT_HEIGNT,dis_str,0,1);
    944          				}
    945          				else
    946          				{
    947          					sprintf(dis_str,"取消    确认% 8d",send_num);
    948          					gui_TextOut(0,GUI_HEIGHT-SHOTCUT_HEIGNT,dis_str,0,1);
    949          				}
    950          			}
    951          			else if (scan_func_state == 1)
    952          			{
    953          				if (g_param.language == LANG_ENGLISH)
    954          				{
    955          					gui_TextOut(0,GUI_HEIGHT-SHOTCUT_HEIGNT,"Esc            Enter",0,1);
    956          				}
    957          				else
    958          				{
    959          					gui_TextOut(0,GUI_HEIGHT-SHOTCUT_HEIGNT,"取消            确认",0,1);
    960          				}
    961          			}	
    962          		}
    963          
    964          		dlg_refresh_flag = 0;
    965          	}
    966          
    967          	if (DLGCB_RUN == type)
    968          	{
    969          		if ((KEY_SCAN == *key)&&(scan_start == 0)&&(task_exit_flag == 0))
    970          		{
    971          			if (scan_func_state == 0)
    972          			{
    973          				scan_start = 1;
    974          				ui_send_command_to_task(TASK_RUN);
    975          				return RUN_RERUN;
    976          			}
    977          		}
    978          
    979          		if (KEY_EXT_1 == *key)
    980          		{
    981          			scan_start = 0;
    982          
    983          			if (BarCode[0] == 0)
    984          			{
    985          				//后台没有扫描到任何条形码
    986          				return RUN_RERUN;
    987          			}
    988          
    989          			//如果是后台扫描到条形码，那么需要将后台获取到的条形码显示出来
    990          			
    991          			//需要先判断，本次输入的条形码是否和上次的一致
    992          			if (strcmp(BarCode,last_BarCode))
    993          			{
    994          				gui_FillRect(0,13,GUI_WIDTH,USERZONE_HEIGHT,BG_COLOR,0);
    995          				if (strlen(BarCode) > 20)
    996          				{
    997          					gui_TextOut(0,13,BarCode,0,0);
    998          				}
    999          				else
   1000          				{
   1001          					gui_TextOut(0,26,BarCode,0,0);
   1002          				}
   1003          				gui_refresh(0,0,GUI_WIDTH,GUI_HEIGHT);
   1004          				strcpy(last_BarCode,BarCode);
   1005          
   1006          				if ((op_context.chkinf_need_update_flag)&&(op_context.chk_info_index))
   1007          				{
   1008          					//更新上一个盘点信息到数据库
   1009          					if(record_module_replace(REC_TYPE_CHECK,op_context.chk_info_index,(unsigned char*)&op_context.check_info_node,(TNODE_MODIFY_INFO*)0))
   1010          					{
   1011          						return err_tip(ERR_TYPE_STOREFAIL);
   1012          					}
   1013          				}
   1014          				p_check_info = (TCHECK_INFO_RECORD*)rec_searchby_tag(REC_TYPE_CHECK,TAG_BARCODE,BarCode,&searched_rec_index);
   1015          				if (p_check_info)
   1016          				{
   1017          					//盘点清单中已经有该条码的信息
   1018          					if (g_param.avoid_dunplication_option)
   1019          					{
   1020          						return err_tip(ERR_TYPE_DUPLICATION);
   1021          					}
   1022          					memcpy((void*)&op_context.check_info_node,(void*)p_check_info,sizeof(TCHECK_INFO_RECORD));
   1023          					op_context.chk_info_index = searched_rec_index;
   1024          				}
   1025          				else
   1026          				{
   1027          					//盘点清单中还没有该条码的信息
   1028          					memset((void*)&op_context.check_info_node,0,sizeof(TCHECK_INFO_RECORD));
   1029          					strcpy(op_context.check_info_node.bar_code,BarCode);
   1030          
   1031          					if (record_module_count(REC_TYPE_CHECK) == CHECK_LIST_MAX_CNT )
   1032          					{
   1033          						return err_tip(ERR_TYPE_OVERALL);
   1034          					}
   1035          
   1036          					if(record_add(REC_TYPE_CHECK,(unsigned char*)&op_context.check_info_node))
   1037          					{
   1038          						OSTimeDlyHMSM(0,0,0,200);
   1039          						if(record_add(REC_TYPE_CHECK,(unsigned char*)&op_context.check_info_node))
   1040          						{
   1041          							return err_tip(ERR_TYPE_STOREFAIL);
   1042          						}
   1043          					}
   1044          
   1045          					op_context.chk_info_index = record_module_count(REC_TYPE_CHECK);
   1046          				}
   1047          
   1048          				if (g_param.database_query_option)
   1049          				{
   1050          					//需要查询数据库
   1051          					p_goods_node = (TGOODS_SPEC_RECORD*)rec_searchby_tag(REC_TYPE_GOODS_LIST,TAG_BARCODE,BarCode,&searched_rec_index);
   1052          					if (p_goods_node)
   1053          					{
   1054          						//在商品清单中搜索到该条码
   1055          						memcpy((void*)&op_context.goods_node,(void*)p_goods_node,sizeof(TGOODS_SPEC_RECORD));
   1056          						op_context.goods_info_index = searched_rec_index;
   1057          
   1058          						op_context.check_info_node.spec_rec_index = op_context.goods_info_index;
   1059          					}
   1060          				}
   1061          
   1062          				op_context.add_value = 1;
   1063          			}
   1064          			else
   1065          			{
   1066          				//与上一次的条码相同
   1067          				if (g_param.avoid_dunplication_option)
   1068          				{
   1069          					return err_tip(ERR_TYPE_DUPLICATION);
   1070          				}
   1071          
   1072          				if (op_context.check_info_node.check_num<999999999)
   1073          				{
   1074          					op_context.add_value = 1;
   1075          				}
   1076          			}
   1077          
   1078          			op_context.check_info_node.check_num += op_context.add_value;
   1079          
   1080          			if (op_context.add_value)
   1081          			{
   1082          				//盘点数量发生了变化
   1083          				op_context.chkinf_need_update_flag = 1;
   1084          			}
   1085          
   1086          			//如果需要获取盘点时间或日期
   1087          			if (g_param.add_time_option || g_param.add_date_option)
   1088          			{
   1089          				GetDateTime();
   1090          				Systime2BCD(op_context.check_info_node.check_time);
   1091          			}
   1092          
   1093          			if (g_param.database_query_option)
   1094          			{
   1095          				//开启了数据库查询选项，需要显示商品的规格信息
   1096          				if (op_context.goods_node.bar_code[0])
   1097          				{
   1098          					gui_TextOut(0,39,op_context.goods_node.name,0,1);
   1099          					strcpy(line3_save,op_context.goods_node.name);
   1100          				}
   1101          				else
   1102          				{
   1103          					if(LANG_ENGLISH == g_param.language)
   1104          					{
   1105          						gui_TextOut(0,39,"**NO SPEC**",0,0);
   1106          						strcpy(line3_save,"**NO SPEC**");
   1107          					}
   1108          					else
   1109          					{
   1110          						gui_TextOut(0,39,"**无商品信息**",0,0);
   1111          						strcpy(line3_save,"**无商品信息**");
   1112          					}
   1113          				}
   1114          			}
   1115          
   1116          			if (g_param.barcode_statistic_option)
   1117          			{
   1118          				//开启了统计功能选项，需要显示该条码的数量
   1119          				
   1120          				sprintf(dis_str,"<%d         >",op_context.check_info_node.check_num);
   1121          				
   1122          				gui_TextOut(0,39,dis_str,0,0);
   1123          				strcpy(line3_save,dis_str);
   1124          			}
   1125          
   1126          			gui_refresh(0,0,GUI_WIDTH,GUI_HEIGHT);
   1127          			send_num = 1;
   1128          
   1129          			if (g_param.transfer_confirm_option || g_param.quantity_enter_mode)
   1130          			{
   1131          				//开启了传输确认选项或者开启了数量录入
   1132          				if (g_param.quantity_enter_mode)
   1133          				{
   1134          					scan_func_state = 2;		//等待输入数量或者确认发送
   1135          					if (g_param.language == LANG_ENGLISH)
   1136          					{
   1137          						gui_TextOut(0,GUI_HEIGHT-SHOTCUT_HEIGNT,"Esc     Enter      1",0,1);
   1138          					}
   1139          					else
   1140          					{
   1141          						gui_TextOut(0,GUI_HEIGHT-SHOTCUT_HEIGNT,"取消    确认       1",0,1);
   1142          					}
   1143          				}
   1144          				else
   1145          				{
   1146          					scan_func_state = 1;		//等待确认发送
   1147          					if (g_param.language == LANG_ENGLISH)
   1148          					{
   1149          						gui_TextOut(0,GUI_HEIGHT-SHOTCUT_HEIGNT,"Esc            Enter",0,1);
   1150          					}
   1151          					else
   1152          					{
   1153          						gui_TextOut(0,GUI_HEIGHT-SHOTCUT_HEIGNT,"取消            确认",0,1);
   1154          					}
   1155          				}	
   1156          
   1157          				return RUN_RERUN;
   1158          			}
   1159          			else
   1160          			{
   1161          				//没有开启传输确认且没有开启录入数量的选项时，扫描到的条码直接试图发送出去
   1162          				transfer_barcode_proc(&op_context.check_info_node,1);
   1163          				return RUN_RERUN;
   1164          			}
   1165          		}
   1166          
   1167          		if (scan_func_state == 1)
   1168          		{
   1169          			if (*key == KEY_SCAN || *key == KEY_RIGHT_SHOTCUT || *key == KEY_ENTER)
   1170          			{
   1171          				transfer_barcode_proc(&op_context.check_info_node,1);
   1172          				if (g_param.language == LANG_ENGLISH)
   1173          				{
   1174          					gui_TextOut(0,GUI_HEIGHT-SHOTCUT_HEIGNT,"Options             ",0,1);
   1175          				}
   1176          				else
   1177          				{
   1178          					gui_TextOut(0,GUI_HEIGHT-SHOTCUT_HEIGNT,"选项                ",0,1);
   1179          				}
   1180          				scan_func_state = 0;
   1181          				return RUN_RERUN;
   1182          			}
   1183          			else if (*key == KEY_ESC || *key == KEY_LEFT_SHOTCUT)
   1184          			{
   1185          				if (g_param.language == LANG_ENGLISH)
   1186          				{
   1187          					gui_TextOut(0,GUI_HEIGHT-SHOTCUT_HEIGNT,"Options             ",0,1);
   1188          				}
   1189          				else
   1190          				{
   1191          					gui_TextOut(0,GUI_HEIGHT-SHOTCUT_HEIGNT,"选项                ",0,1);
   1192          				}
   1193          				scan_func_state = 0;
   1194          				return RUN_RETURN;
   1195          			}
   1196          		}
   1197          		else if (scan_func_state == 2)
   1198          		{
   1199          			if (*key == KEY_RIGHT_SHOTCUT)
   1200          			{
   1201          				*key = KEY_EXT_9;
   1202          				return RUN_NEXT;
   1203          			}
   1204          			else if (*key == KEY_ENTER || *key == KEY_SCAN)
   1205          			{
   1206          				transfer_barcode_proc(&op_context.check_info_node,send_num);
   1207          				scan_func_state = 0;
   1208          				if (g_param.language == LANG_ENGLISH)
   1209          				{
   1210          					gui_TextOut(0,GUI_HEIGHT-SHOTCUT_HEIGNT,"Options             ",0,1);
   1211          				}
   1212          				else
   1213          				{
   1214          					gui_TextOut(0,GUI_HEIGHT-SHOTCUT_HEIGNT,"选项                ",0,1);
   1215          				}
   1216          				return RUN_RERUN;
   1217          			}
   1218          			else if (*key == KEY_ESC || *key == KEY_LEFT_SHOTCUT)
   1219          			{
   1220          				if (g_param.language == LANG_ENGLISH)
   1221          				{
   1222          					gui_TextOut(0,GUI_HEIGHT-SHOTCUT_HEIGNT,"Options             ",0,1);
   1223          				}
   1224          				else
   1225          				{
   1226          					gui_TextOut(0,GUI_HEIGHT-SHOTCUT_HEIGNT,"选项                ",0,1);
   1227          				}
   1228          				scan_func_state = 0;
   1229          				return RUN_RETURN;
   1230          			}
   1231          		}
   1232          		else
   1233          		{
   1234          			if ((scan_func_state & 0x10) == 0x10)
   1235          			{
   1236          				//显示商品规格的状态，只响应KEY_UP键和KEY_ESC键
   1237          				if(*key == KEY_UP || *key == KEY_ESC)
   1238          				{
   1239          					scan_func_state &= 0x0f;
   1240          					dlg_refresh_flag = 1;
   1241          					no_update_icon_flg = 0;
   1242          					update_icon_cnt = 5;
   1243          					gui_FillRect(0,0,GUI_WIDTH,ICON_HEIGHT, BG_COLOR,0);
   1244          					gui_LineH(0,ICON_HEIGHT,GUI_WIDTH,TXT_COLOR,0);
   1245          					dlg_update_icon(0,0);
   1246          					gui_refresh(0,0,GUI_WIDTH,GUI_HEIGHT/2);
   1247          					dlg_updatetime(52, 0);
   1248          					return RUN_RETURN;
   1249          				}
   1250          				else
   1251          				{
   1252          					return RUN_RERUN;
   1253          				}
   1254          			}
   1255          
   1256          			if (*key == KEY_ESC)
   1257          			{
   1258          				if ((op_context.chkinf_need_update_flag)&&(op_context.chk_info_index))
   1259          				{
   1260          					//更新上一个盘点信息到数据库
   1261          					if(record_module_replace(REC_TYPE_CHECK,op_context.chk_info_index,(unsigned char*)&op_context.check_info_node,(TNODE_MODIFY_INFO*)0))
   1262          					{
   1263          						err_tip(ERR_TYPE_STOREFAIL);
   1264          						task_exit_flag = 1;
   1265          						OSTimeDlyHMSM(0,0,1,0);
   1266          						task_exit_flag = 0;
   1267          						return RUN_NEXT;
   1268          					}
   1269          				}
   1270          			}
   1271          		}
   1272          
   1273          		if ((*key == KEY_DOWN)&&(g_param.database_query_option != 0)&&(op_context.goods_node.bar_code[0] != 0))
   1274          		{
   1275          			if (display_goods_spec())
   1276          			{
   1277          				scan_func_state |= 0x10;
   1278          			}
   1279          			return RUN_RERUN;
   1280          		}
   1281          	}
   1282          
   1283          	return RUN_CONTINUE;
   1284          }
   1285          
   1286          
   1287          /**
   1288          * @brief 只需要通过上下翻页键选择菜单，然后通过ENTER键跳转到下一级菜单的窗体的通用处理函数
   1289          * note   注意这些窗体的跳转键值必须与菜单项设置为相应的KEY_EXT_1,KEY_EXT_2,...
   1290          */
   1291          static unsigned char proc_list_menu(unsigned char type,unsigned char *key)
   1292          {
   1293          	if (DLGCB_RUN == type)
   1294          	{
   1295          		if (KEY_SCAN == *key || KEY_ENTER == *key)
   1296          		{
   1297          			*key = KEY_EXT_1 + menu_current_item - 1;
   1298          			saveDrawContext();	//保存当前菜单在跳转到子菜单时的状态
   1299          			return RUN_NEXT;
   1300          		}
   1301          
   1302          		if (KEY_RIGHT_SHOTCUT == *key)
   1303          		{
   1304          			*key = KEY_ESC;
   1305          			releaseDrawContext();
   1306          			return RUN_NEXT;
   1307          		}
   1308          
   1309          	}
   1310          	return RUN_CONTINUE;
   1311          }
   1312          
   1313          /**
   1314          * @brief 扫描功能选项
   1315          */
   1316          static unsigned char dlgproc_scan_option_menu(unsigned char type,unsigned char *key)
   1317          {
   1318          	return proc_list_menu(type,key);
   1319          }
   1320          
   1321          /**
   1322          * @brief 系统信息
   1323          */
   1324          static unsigned char dlgproc_system_info(unsigned char type,unsigned char *key)
   1325          {
   1326          	//return proc_list_menu(type,key);
   1327          
   1328          	if (DLGCB_CREATE == type)
   1329          	{
   1330          		special_func_flag = 0;
   1331          	}
   1332          
   1333          	if (DLGCB_RUN == type)
   1334          	{
   1335          		if (KEY_SCAN == *key || KEY_ENTER == *key)
   1336          		{
   1337          			*key = KEY_EXT_1 + menu_current_item - 1;
   1338          			saveDrawContext();	//保存当前菜单在跳转到子菜单时的状态
   1339          			return RUN_NEXT;
   1340          		}
   1341          
   1342          		if (KEY_RIGHT_SHOTCUT == *key)
   1343          		{
   1344          			*key = KEY_ESC;
   1345          			releaseDrawContext();
   1346          			return RUN_NEXT;
   1347          		}
   1348          
   1349          		//输入特殊按键序列: "LEFT_SHOTCUT、LEFT、RIGHT、LEFT_SHOTCUT、LEFT、RIGHT、LEFT_SHOTCUT" 进入隐藏功能菜单
   1350          		if ((KEY_LEFT_SHOTCUT == *key)&&(special_func_flag == 0))
   1351          		{
   1352          			special_func_flag = 1;
   1353          			return RUN_RERUN;
   1354          		}
   1355          
   1356          		if (1 == special_func_flag)
   1357          		{	
   1358          			if ( KEY_LEFT == *key)
   1359          			{
   1360          				special_func_flag = 2;
   1361          			}
   1362          			else
   1363          			{
   1364          				special_func_flag = 0;
   1365          			}
   1366          			return RUN_RERUN;
   1367          		}
   1368          
   1369          		if (2 == special_func_flag)
   1370          		{	
   1371          			if ( KEY_RIGHT == *key)
   1372          			{
   1373          				special_func_flag = 3;
   1374          			}
   1375          			else
   1376          			{
   1377          				special_func_flag = 0;
   1378          			}
   1379          			return RUN_RERUN;
   1380          		}
   1381          
   1382          		if (3 == special_func_flag)
   1383          		{	
   1384          			if ( KEY_LEFT_SHOTCUT == *key)
   1385          			{
   1386          				special_func_flag = 4;
   1387          			}
   1388          			else
   1389          			{
   1390          				special_func_flag = 0;
   1391          			}
   1392          			return RUN_RERUN;
   1393          		}
   1394          
   1395          		if (4 == special_func_flag)
   1396          		{	
   1397          			if ( KEY_LEFT == *key)
   1398          			{
   1399          				special_func_flag = 5;
   1400          			}
   1401          			else
   1402          			{
   1403          				special_func_flag = 0;
   1404          			}
   1405          			return RUN_RERUN;
   1406          		}
   1407          
   1408          		if (5 == special_func_flag)
   1409          		{	
   1410          			if ( KEY_RIGHT == *key)
   1411          			{
   1412          				special_func_flag = 6;
   1413          			}
   1414          			else
   1415          			{
   1416          				special_func_flag = 0;
   1417          			}
   1418          			return RUN_RERUN;
   1419          		}
   1420          
   1421          		if (6 == special_func_flag)
   1422          		{	
   1423          			if ( KEY_LEFT_SHOTCUT == *key)
   1424          			{
   1425          				*key = KEY_EXT_9;
   1426          				return RUN_NEXT;
   1427          			}
   1428          			else
   1429          			{
   1430          				special_func_flag = 0;
   1431          			}
   1432          			return RUN_RERUN;
   1433          		}
   1434          
   1435          
   1436          	}
   1437          	return RUN_CONTINUE;
   1438          }
   1439          
   1440          
   1441          
   1442          /**
   1443          * @brief	终端设置菜单
   1444          */
   1445          static unsigned char dlgproc_terminal_setting(unsigned char type,unsigned char *key)
   1446          {
   1447          	return proc_list_menu(type,key);
   1448          }
   1449          
   1450          
   1451          static void refresh_current_select_item(unsigned char current_set,unsigned char refresh_flag)
   1452          {
   1453          	unsigned char i = 0;
   1454          
   1455          	while (display_menu_item_array[i])
   1456          	{
   1457          		if (display_menu_item_array[i] == current_set)
   1458          		{
   1459          			gui_PictureOut(GUI_WIDTH - 24,ICON_HEIGHT+1+i*13,PIC_GOU,refresh_flag);
   1460          			//break;
   1461          		}
   1462          		else
   1463          		{
   1464          			gui_FillRect(GUI_WIDTH - 24,ICON_HEIGHT+1+i*13,24,13,BG_COLOR,refresh_flag);
   1465          		}
   1466                  i++;
   1467          	}
   1468          }
   1469          
   1470          /**
   1471          * @brief 数据传输方式的选择
   1472          */
   1473          static unsigned char dlgproc_data_transfer_func(unsigned char type,unsigned char *key)
   1474          {
   1475          	if (DLGCB_DRAW == type)
   1476          	{
   1477          		//显示当前设置的数据传输模式
   1478          		refresh_current_select_item(g_param.transfer_mode,1);
   1479          
   1480          		if (menu_current_item == 1 || menu_current_item == 4 || menu_current_item == 5)
   1481          		{
   1482          			if (g_param.language == LANG_ENGLISH)
   1483          			{
   1484          				gui_TextOut(0,GUI_HEIGHT-SHOTCUT_HEIGNT,"Option",0,1);
   1485          			}
   1486          			else
   1487          			{
   1488          				gui_TextOut(0,GUI_HEIGHT-SHOTCUT_HEIGNT,"选项",0,1);
   1489          			}
   1490          		}
   1491          	}
   1492          
   1493          	if (DLGCB_RUN == type)
   1494          	{
   1495          		if (KEY_ENTER == *key || KEY_SCAN == *key)
   1496          		{
   1497          			if (menu_current_item == 6 || menu_current_item == 7)
   1498          			{
   1499          				//导入商品信息
   1500          				*key = KEY_EXT_1 + menu_current_item - 1;
   1501          				saveDrawContext();
   1502          				return RUN_NEXT;
   1503          			}
   1504          			else
   1505          			{
   1506          				g_param.transfer_mode = menu_current_item;
   1507          				refresh_current_select_item(g_param.transfer_mode,1);
   1508          				device_init_by_setting();
   1509          				return RUN_RERUN;
   1510          			}
   1511          		}
   1512          
   1513          		if (KEY_LEFT_SHOTCUT == *key)
   1514          		{
   1515          			if (menu_current_item == 1 || menu_current_item == 4 || menu_current_item == 5)
   1516          			{
   1517          				*key = KEY_EXT_1+menu_current_item - 1;
   1518          				saveDrawContext();
   1519          				return RUN_NEXT;
   1520          			}
   1521          			else
   1522          			{
   1523          				return RUN_RERUN;
   1524          			}
   1525          		}
   1526          
   1527          		if (KEY_ESC == *key || KEY_RIGHT_SHOTCUT == *key)
   1528          		{
   1529          			*key = KEY_ESC;
   1530          			SaveTerminalPara();
   1531          			releaseDrawContext();
   1532          			return RUN_NEXT;
   1533          		}
   1534          	}
   1535          
   1536          	if (DLGCB_PAGECHANGE == type)
   1537          	{
   1538          		refresh_current_select_item(g_param.transfer_mode,1);
   1539          		if (menu_current_item == 1 || menu_current_item == 4 || menu_current_item == 5)
   1540          		{
   1541          			if (g_param.language == LANG_ENGLISH)
   1542          			{
   1543          				gui_TextOut(0,GUI_HEIGHT-SHOTCUT_HEIGNT,"Option",0,1);
   1544          			}
   1545          			else
   1546          			{
   1547          				gui_TextOut(0,GUI_HEIGHT-SHOTCUT_HEIGNT,"选项",0,1);
   1548          			}
   1549          		}
   1550          		else
   1551          		{
   1552          			gui_TextOut(0,GUI_HEIGHT-SHOTCUT_HEIGNT,"    ",0,1);
   1553          		}
   1554          	}
   1555          
   1556          	if (DLGCB_DESTORY == type)
   1557          	{
   1558          		//device_init_by_setting();
   1559          	}
   1560          
   1561          	return RUN_CONTINUE;
   1562          }
   1563          
   1564          
   1565          //发送脱机数据的任务
   1566          unsigned int batch_data_send_proc(void)
   1567          {
   1568          	unsigned int cnt,i;
   1569          	TBATCH_NODE * pbatch_data;
   1570          
   1571          	cnt = record_module_count(REC_TYPE_BATCH);
   1572          	for(i = 0; i < cnt;i++)
   1573          	{
   1574          		if (check_link_state(g_param.batch_transfer_mode) == 0)
   1575          		{
   1576          			break;
   1577          		}
   1578          
   1579          		pbatch_data = (TBATCH_NODE*)record_module_read(REC_TYPE_BATCH,i+1);
   1580          		if (pbatch_data)
   1581          		{
   1582          			transfer_barcode_str(pbatch_data->batch_str,g_param.batch_transfer_mode);
   1583          		}
   1584          
   1585          		//delete_one_node(REC_TYPE_BATCH,i+1);	//将该脱机记录删除，表示已发送
   1586          	}
   1587          
   1588          	return i;
   1589          }
   1590          
   1591          /**
   1592          * @brief 脱机数据传输
   1593          */
   1594          static unsigned char dlgproc_batch_data_send(unsigned char type,unsigned char *key)
   1595          {
   1596          	unsigned int cnt;
   1597          	unsigned char str[21];
   1598          
   1599          	if (DLGCB_DRAW == type)
   1600          	{
   1601          		if (check_link_state(g_param.batch_transfer_mode) == 0)
   1602          		{
   1603          			Beep(BEEP_DELAY*2);
   1604          			if (g_param.language == LANG_ENGLISH)
   1605          			{
   1606          				gui_TextOut(0,26,"Check Device is Connected!",0,1);
   1607          			}
   1608          			else
   1609          			{
   1610          				gui_TextOut(0,26,"请确认设备处于连接状态!",0,1);
   1611          			}
   1612          		}
   1613          		else
   1614          		{
   1615          			if (record_module_count(REC_TYPE_BATCH) == 0)
   1616          			{
   1617          				if (g_param.language == LANG_ENGLISH)
   1618          				{
   1619          					gui_TextOut(0,26,"No Batch Data!",0,1);
   1620          				}
   1621          				else
   1622          				{
   1623          					gui_TextOut(0,26,"没有脱机数据",0,1);
   1624          				}
   1625          			}
   1626          			else
   1627          			{
   1628          				if (g_param.language == LANG_ENGLISH)
   1629          				{
   1630          					gui_TextOut(0,26,"Sending,Wait a minute",0,1);
   1631          				}
   1632          				else
   1633          				{
   1634          					gui_TextOut(0,26,"正在发送,请稍候...",0,1);
   1635          				}
   1636          
   1637          				cnt = batch_data_send_proc();
   1638          
   1639          				if (g_param.language == LANG_ENGLISH)
   1640          				{
   1641          					sprintf(str,"Send %d barcodes!",cnt);
   1642          				}
   1643          				else
   1644          				{
   1645          					sprintf(str,"发送了%d条数据!",cnt);
   1646          				}
   1647          				gui_TextOut(0,39,str,0,1);
   1648          			}
   1649          			
   1650          		}
   1651          	}
   1652          
   1653          	return RUN_CONTINUE;
   1654          }
   1655          
   1656          /**
   1657          * @brief 脱机数据传输方式的选择
   1658          */
   1659          static unsigned char dlgproc_batch_transfer_mode(unsigned char type,unsigned char *key)
   1660          {
   1661          	if (DLGCB_DRAW == type)
   1662          	{
   1663          		//显示当前设置的数据传输模式
   1664          		refresh_current_select_item(g_param.batch_transfer_mode,1);
   1665          	}
   1666          
   1667          	if (DLGCB_RUN == type)
   1668          	{
   1669          		if (KEY_ENTER == *key || KEY_SCAN == *key)
   1670          		{
   1671          
   1672          			g_param.batch_transfer_mode = menu_current_item;
   1673          			refresh_current_select_item(g_param.batch_transfer_mode,1);
   1674          			return RUN_RERUN;
   1675          		}
   1676          
   1677          		if (KEY_ESC == *key || KEY_RIGHT_SHOTCUT == *key)
   1678          		{
   1679          			*key = KEY_ESC;
   1680          			SaveTerminalPara();
   1681          			return RUN_NEXT;
   1682          		}
   1683          	}
   1684          
   1685          	//if (DLGCB_PAGECHANGE == type)
   1686          	//{
   1687          	//	refresh_current_select_item(g_param.batch_transfer_mode,1);
   1688          	//}
   1689          
   1690          	if (DLGCB_DESTORY == type)
   1691          	{
   1692          		device_init_by_setting();
   1693          	}
   1694          
   1695          	return RUN_CONTINUE;
   1696          }
   1697          
   1698          
   1699          /**
   1700          * @brief 脱机数据清除
   1701          */
   1702          static unsigned char dlgproc_batch_data_clear(unsigned char type,unsigned char *key)
   1703          {
   1704          	if (DLGCB_DRAW == type)
   1705          	{
   1706          		if (g_param.language == LANG_ENGLISH)
   1707          		{
   1708          			gui_TextOut(0,20,"Batch data will be delete,Continue?",0,1);
   1709          		}
   1710          		else
   1711          		{
   1712          			gui_TextOut_ext(CENTER_ALIGN,20,"脱机数据将被清除",0,1);
   1713          			gui_TextOut_ext(CENTER_ALIGN,33,"是否继续?",0,1);
   1714          		}
   1715          	}
   1716          
   1717          	if (DLGCB_RUN == type)
   1718          	{
   1719          		if ((KEY_RIGHT_SHOTCUT == *key)&&(task_exit_flag == 0))
   1720          		{
   1721          			if(record_clear(REC_TYPE_BATCH))
   1722          			{
   1723          				if (g_param.language == LANG_ENGLISH)
   1724          				{
   1725          					gui_TextOut_ext(CENTER_ALIGN,26,"Data delete fail!",0,1);
   1726          				}
   1727          				else
   1728          				{
   1729          					gui_TextOut_ext(CENTER_ALIGN,26,"数据清除失败!",0,1);
   1730          				}
   1731          			}
   1732          			else
   1733          			{
   1734          				if (g_param.language == LANG_ENGLISH)
   1735          				{
   1736          					gui_TextOut_ext(CENTER_ALIGN,26,"Data delete success!",0,1);
   1737          				}
   1738          				else
   1739          				{
   1740          					gui_TextOut_ext(CENTER_ALIGN,26,"数据清除成功!",0,1);
   1741          				}
   1742          			}
   1743          
   1744          			task_exit_flag = 1;
   1745          			OSTimeDlyHMSM(0,0,1,0);
   1746          			task_exit_flag = 0;
   1747          			*key = KEY_ESC;
   1748          			return RUN_NEXT;
   1749          		}
   1750          	}
   1751          
   1752          	return RUN_CONTINUE;
   1753          }
   1754          
   1755          
   1756          
   1757          
   1758          /**
   1759          * @brief 清除扫描记录
   1760          */
   1761          static unsigned char dlgproc_clear_scan_record(unsigned char type,unsigned char *key)
   1762          {
   1763          	if (DLGCB_DRAW == type)
   1764          	{
   1765          		if (g_param.language == LANG_ENGLISH)
   1766          		{
   1767          			gui_TextOut(0,20,"Scan record will be delete,Continue?",0,1);
   1768          		}
   1769          		else
   1770          		{
   1771          			gui_TextOut_ext(CENTER_ALIGN,20,"扫描记录将被清除",0,1);
   1772          			gui_TextOut_ext(CENTER_ALIGN,33,"是否继续?",0,1);
   1773          		}
   1774          	}
   1775          
   1776          	if (DLGCB_RUN == type)
   1777          	{
   1778          		if ((KEY_RIGHT_SHOTCUT == *key)&&(task_exit_flag == 0))
   1779          		{
   1780          			if(record_clear(REC_TYPE_CHECK))
   1781          			{
   1782          				if (g_param.language == LANG_ENGLISH)
   1783          				{
   1784          					gui_TextOut_ext(CENTER_ALIGN,26,"Data delete fail!",0,1);
   1785          				}
   1786          				else
   1787          				{
   1788          					gui_TextOut_ext(CENTER_ALIGN,26,"数据清除失败!",0,1);
   1789          				}
   1790          			}
   1791          			else
   1792          			{
   1793          				if (g_param.language == LANG_ENGLISH)
   1794          				{
   1795          					gui_TextOut_ext(CENTER_ALIGN,26,"Data delete success!",0,1);
   1796          				}
   1797          				else
   1798          				{
   1799          					gui_TextOut_ext(CENTER_ALIGN,26,"数据清除成功!",0,1);
   1800          				}
   1801          			}
   1802          
   1803          			task_exit_flag = 1;
   1804          			OSTimeDlyHMSM(0,0,1,0);
   1805          			task_exit_flag = 0;
   1806          			*key = KEY_ESC;
   1807          			return RUN_NEXT;
   1808          		}
   1809          	}
   1810          
   1811          	return RUN_CONTINUE;
   1812          }
   1813          
   1814          /**
   1815          * @brief 扫描模式选择
   1816          */
   1817          static unsigned char dlgproc_scan_mode_menu(unsigned char type,unsigned char *key)
   1818          {
   1819          	if (DLGCB_DRAW == type)
   1820          	{
   1821          		//显示当前设置的扫描模式
   1822          		refresh_current_select_item(g_param.scan_trig_mode,1);
   1823          	}
   1824          
   1825          	if (DLGCB_RUN == type)
   1826          	{
   1827          		if (KEY_ENTER == *key || KEY_SCAN == *key)
   1828          		{
   1829          			g_param.scan_trig_mode = menu_current_item;
   1830          			refresh_current_select_item(g_param.scan_trig_mode,1);
   1831          		}
   1832          
   1833          		if (KEY_ESC == *key || KEY_RIGHT_SHOTCUT == *key)
   1834          		{
   1835          			*key = KEY_ESC;
   1836          			SaveTerminalPara();
   1837          			return RUN_NEXT;
   1838          		}
   1839          	}
   1840          
   1841          	return RUN_CONTINUE;
   1842          }
   1843          
   1844          /**
   1845          * @brief 选项选择的通用处理函数
   1846          * 注意:选项必须是0,1,2，.....(0开始)
   1847          */
   1848          static unsigned char proc_option_select(unsigned char type,unsigned char *key,unsigned char *param)
   1849          {
   1850          	if (DLGCB_DRAW == type)
   1851          	{
   1852          		//显示当前设置的选项
   1853          		refresh_current_select_item(*param+1,1);
   1854          	}
   1855          
   1856          	if (DLGCB_RUN == type)
   1857          	{
   1858          		if (KEY_ENTER == *key || KEY_SCAN == *key)
   1859          		{
   1860          			*param = menu_current_item-1;
   1861          			refresh_current_select_item(*param+1,1);
   1862          		}
   1863          
   1864          		if (KEY_ESC == *key || KEY_RIGHT_SHOTCUT == *key)
   1865          		{
   1866          			*key = KEY_ESC;
   1867          			if (param == &g_param.language)
   1868          			{
   1869          				gui_setlanguage(g_param.language);
   1870          			}
   1871          			else if (param == &g_param.avoid_dunplication_option)
   1872          			{
   1873          				if (g_param.avoid_dunplication_option)
   1874          				{
   1875          					//如果开启了防重码，那么就需要关闭数据统计功能和数据库查询功能
   1876          					g_param.database_query_option = 0;
   1877          					g_param.barcode_statistic_option = 0;
   1878          				}
   1879          			}
   1880          			else if (param == &g_param.database_query_option)
   1881          			{
   1882          				if (g_param.database_query_option)
   1883          				{
   1884          					//如果开启了数据库查询，那么就需要关闭数据统计功能和防重码功能
   1885          					g_param.avoid_dunplication_option = 0;
   1886          					g_param.barcode_statistic_option = 0;
   1887          				}
   1888          			}
   1889          			else if (param == &g_param.barcode_statistic_option)
   1890          			{
   1891          				if (g_param.barcode_statistic_option)
   1892          				{
   1893          					//如果开启了数据统计，那么就需要关闭防重码功能和数据库查询功能
   1894          					g_param.database_query_option = 0;
   1895          					g_param.avoid_dunplication_option = 0;
   1896          				}
   1897          			}
   1898          			SaveTerminalPara();
   1899          			return RUN_NEXT;
   1900          		}
   1901          
   1902          		if (DLGCB_PAGECHANGE == type)
   1903          		{
   1904          			refresh_current_select_item(*param+1,1);
   1905          		}
   1906          	}
   1907          
   1908          	return RUN_CONTINUE;
   1909          }
   1910          
   1911          /**
   1912          * @brief 数据输入模式选择
   1913          */
   1914          static unsigned char dlgproc_quantity_enter_menu(unsigned char type,unsigned char *key)
   1915          {
   1916          	return proc_option_select(type,key,&g_param.quantity_enter_mode);
   1917          }
   1918          
   1919          
   1920          
   1921          /**
   1922          * @brief 添加时间选择
   1923          */
   1924          static unsigned char dlgproc_add_time_option(unsigned char type,unsigned char *key)
   1925          {
   1926          	return proc_option_select(type,key,&g_param.add_time_option);
   1927          }
   1928          
   1929          /**
   1930          * @brief 添加日期选择
   1931          */
   1932          static unsigned char dlgproc_add_date_option(unsigned char type,unsigned char *key)
   1933          {
   1934          	return proc_option_select(type,key,&g_param.add_date_option);
   1935          }
   1936          
   1937          
   1938          /**
   1939          * @brief 手动输入条码
   1940          */
   1941          static unsigned char dlgproc_input_barcode(unsigned char type,unsigned char *key)
   1942          {
   1943          	if (DLGCB_CREATE == type)
   1944          	{
   1945          		g_dlg.edit.pRes		= g_dlg.pRes->pEdit;
   1946          		edit_init(&g_dlg.edit);
   1947          		return RUN_EDIT_PROC;
   1948          	}
   1949          
   1950          	if (DLGCB_BACK_FROM_VIRTUAL_KEYPAD == type)
   1951          	{
   1952          		if (KEY_ESC == *key)
   1953          		{
   1954          			memset(BarCode,0,31);
   1955          			return RUN_NEXT;
   1956          		}
   1957          
   1958          		if (KEY_LEFT_SHOTCUT == *key)
   1959          		{
   1960          			strcpy(BarCode,g_editValue[0]);
   1961          			send_num = 1;
   1962          			strcpy(op_context.check_info_node.bar_code,BarCode);
   1963          			dlg_refresh_flag = 1;
   1964          			if (g_param.quantity_enter_mode)
   1965          			{
   1966          				scan_func_state = 2;
   1967          			}
   1968          			else
   1969          			{
   1970          				//if (g_param.transfer_confirm_option)
   1971          				//{
   1972          					scan_func_state = 1;
   1973          				//}
   1974          			}
   1975          
   1976          			if (g_param.add_time_option || g_param.add_date_option)
   1977          			{
   1978          				GetDateTime();
   1979          				Systime2BCD(op_context.check_info_node.check_time);
   1980          			}
   1981          
   1982          			if (g_param.database_query_option)
   1983          			{
   1984          				p_goods_node = (TGOODS_SPEC_RECORD*)rec_searchby_tag(REC_TYPE_GOODS_LIST,TAG_BARCODE,BarCode,&searched_rec_index);
   1985          				if (p_goods_node)
   1986          				{
   1987          					//在商品清单中搜索到该条码
   1988          					memcpy((void*)&op_context.goods_node,(void*)p_goods_node,sizeof(TGOODS_SPEC_RECORD));
   1989          					op_context.goods_info_index = searched_rec_index;
   1990          
   1991          					op_context.check_info_node.spec_rec_index = op_context.goods_info_index;
   1992          					strcpy(line3_save,op_context.goods_node.name);
   1993          				}
   1994          				else
   1995          				{
   1996          					if(LANG_ENGLISH == g_param.language)
   1997          					{
   1998          						strcpy(line3_save,"**NO SPEC**");
   1999          					}
   2000          					else
   2001          					{
   2002          						strcpy(line3_save,"**无商品信息**");
   2003          					}
   2004          				}
   2005          			}
   2006          
   2007          
   2008          			*key = KEY_EXT_1;
   2009          			return RUN_NEXT;
   2010          		}
   2011          	}
   2012          	return RUN_CONTINUE;
   2013          }
   2014          
   2015          
   2016          /**
   2017          * @brief 设置分隔符
   2018          */
   2019          static unsigned char dlgproc_seperator_setting(unsigned char type,unsigned char *key)
   2020          {
   2021          	if (DLGCB_CREATE == type)
   2022          	{
   2023          		g_dlg.edit.pRes		= g_dlg.pRes->pEdit;
   2024          		edit_init(&g_dlg.edit);
   2025          		edit_setvalue(&g_dlg.edit,g_param.transfer_seperator,0);
   2026          		edit_refresh_ext(&g_dlg.edit);
   2027          		return RUN_EDIT_PROC;
   2028          	}
   2029          
   2030          	if (DLGCB_BACK_FROM_VIRTUAL_KEYPAD == type)
   2031          	{
   2032          		if (KEY_LEFT_SHOTCUT == *key)
   2033          		{
   2034          			strcpy(g_param.transfer_seperator,g_editValue[0]);
   2035          			SaveTerminalPara();
   2036          			*key = KEY_ESC;
   2037          			return RUN_NEXT;
   2038          		}
   2039          
   2040          		if (KEY_ESC == *key)
   2041          		{
   2042          			return RUN_NEXT;
   2043          		}
   2044          	}
   2045          	return RUN_CONTINUE;
   2046          }
   2047          
   2048          
   2049          /**
   2050          * @brief 修改发送数量
   2051          */
   2052          static unsigned char dlgproc_input_send_num(unsigned char type,unsigned char *key)
   2053          {
   2054          	unsigned char str[11];
   2055          
   2056          	if (DLGCB_CREATE == type)
   2057          	{
   2058          		g_dlg.edit.pRes		= g_dlg.pRes->pEdit;
   2059          		edit_init(&g_dlg.edit);
   2060          		edit_itoa(send_num,str);
   2061          		edit_setvalue(&g_dlg.edit,str,0);
   2062          		return RUN_EDIT_PROC;
   2063          	}
   2064          
   2065          	if (DLGCB_BACK_FROM_VIRTUAL_KEYPAD == type)
   2066          	{
   2067          		if (KEY_ESC == *key)
   2068          		{
   2069          			return RUN_NEXT;
   2070          		}
   2071          
   2072          		if (KEY_LEFT_SHOTCUT == *key)
   2073          		{
   2074          			send_num = edit_atoi(g_editValue[0]);
   2075          			*key = KEY_EXT_1;
   2076          			return RUN_NEXT;
   2077          		}
   2078          	}
   2079          	return RUN_CONTINUE;
   2080          }
   2081          
   2082          /**
   2083          * @brief 确认修改发送数量
   2084          */
   2085          static unsigned char dlgproc_modify_num_ack(unsigned char type,unsigned char *key)
   2086          {
   2087          	if (DLGCB_DRAW == type)
   2088          	{
   2089          		if (g_param.language == LANG_ENGLISH)
   2090          		{
   2091          			gui_TextOut_ext(CENTER_ALIGN,26,"Modify the number?",0,1);
   2092          		}
   2093          		else
   2094          		{
   2095          			gui_TextOut_ext(CENTER_ALIGN,26,"确定修改数量?",0,1);
   2096          		}
   2097          	}
   2098          
   2099          	if (DLGCB_RUN == type)
   2100          	{
   2101          		if (KEY_RIGHT_SHOTCUT == *key || KEY_ESC == *key)
   2102          		{
   2103          			*key = KEY_ESC;
   2104          			send_num = 1;
   2105          			dlg_refresh_flag = 1;
   2106          			return RUN_NEXT;
   2107          		}
   2108          
   2109          		if (KEY_LEFT_SHOTCUT == *key || KEY_ENTER == *key)
   2110          		{
   2111          			*key = KEY_ENTER;
   2112          			dlg_refresh_flag = 1;
   2113          			return RUN_NEXT;
   2114          		}
   2115          	}
   2116          	return RUN_CONTINUE;
   2117          }
   2118          
   2119          
   2120          /**
   2121          * @brief 数据库查询选择
   2122          */
   2123          static unsigned char dlgproc_database_query_option(unsigned char type,unsigned char *key)
   2124          {
   2125          	return proc_option_select(type,key,&g_param.database_query_option);
   2126          }
   2127          
   2128          /**
   2129          * @brief 防重码功能开启选择
   2130          */
   2131          static unsigned char dlgproc_avoid_dunplication_option(unsigned char type,unsigned char *key)
   2132          {
   2133          	return proc_option_select(type,key,&g_param.avoid_dunplication_option);
   2134          }
   2135          
   2136          
   2137          /**
   2138          * @brief 条码统计功能开启选择
   2139          */
   2140          static unsigned char dlgproc_barcode_statistic_option(unsigned char type,unsigned char *key)
   2141          {
   2142          	return proc_option_select(type,key,&g_param.barcode_statistic_option);
   2143          }
   2144          
   2145          /**
   2146          * @brief 传输确认功能开启选择
   2147          */
   2148          static unsigned char dlgproc_transfer_confirm_option(unsigned char type,unsigned char *key)
   2149          {
   2150          	return proc_option_select(type,key,&g_param.transfer_confirm_option);
   2151          }
   2152          
   2153          /**
   2154          * @brief 语言选择
   2155          */
   2156          static unsigned char dlgproc_language_option(unsigned char type,unsigned char *key)
   2157          {
   2158          	return proc_option_select(type,key,&g_param.language);
   2159          }
   2160          
   2161          
   2162          /**
   2163          * @brief 按键音开关选择
   2164          */
   2165          static unsigned char dlgproc_beeper_vol_option(unsigned char type,unsigned char *key)
   2166          {
   2167          	return proc_option_select(type,key,&g_param.beeper_vol);
   2168          }
   2169          
   2170          
   2171          /**
   2172          * @brief 超时选择
   2173          */
   2174          static unsigned char dlgproc_timeout_option(unsigned char type,unsigned char *key)
   2175          {
   2176          	return proc_option_select(type,key,&g_param.operate_timeout);
   2177          }
   2178          
   2179          /**
   2180          * @brief 蓝牙传输模式选项
   2181          */
   2182          static unsigned char dlgproc_transfer_bluetooth_option(unsigned char type,unsigned char *key)
   2183          {
   2184          	return proc_option_select(type,key,&g_param.bluetooth_transfer_option);
   2185          }
   2186          
   2187          /**
   2188          * @brief U盘传输模式选项
   2189          */
   2190          static unsigned char dlgproc_transfer_u_disk_option(unsigned char type,unsigned char *key)
   2191          {
   2192          	return proc_list_menu(type,key);
   2193          }
   2194          
   2195          /**
   2196          * @brief 脱机数据处理选项
   2197          */
   2198          static unsigned char dlgproc_transfer_batch_option(unsigned char type,unsigned char *key)
   2199          {
   2200          	return proc_list_menu(type,key);
   2201          }
   2202          
   2203          
   2204          /**
   2205          ***************************************************************************
   2206          *@brief 显示会话结果
   2207          *@param[in] 
   2208          *@return 
   2209          *@warning
   2210          *@see	
   2211          ***************************************************************************
   2212          */
   2213          static void display_hh_result(int trans_type,unsigned char key)
   2214          {
   2215          	gui_FillRect(0,ICON_HEIGHT+1,GUI_WIDTH,USERZONE_HEIGHT-1,BG_COLOR,0);
   2216          
   2217          	if ((key == KEY_GPRS_S1)||(key == KEY_GPRS_S2))
   2218          	{
   2219          		if (LANG_ENGLISH == g_param.language)
   2220          		{
   2221          			gui_TextOut_ext(CENTER_ALIGN,26,"Import Goods Info",0,0);
   2222          			//@English
   2223          		}
   2224          		else
   2225          		{
   2226          			gui_TextOut_ext(CENTER_ALIGN,26,"商品信息导入",0,0);
   2227          		}
   2228          
   2229          		if (LANG_ENGLISH == g_param.language)
   2230          		{
   2231          			if (key == KEY_GPRS_S2)
   2232          			{
   2233          				gui_TextOut_ext(CENTER_ALIGN,39,"Fail",0,0);
   2234          				//@English
   2235          			}
   2236          			else
   2237          			{
   2238          				gui_TextOut_ext(CENTER_ALIGN,39,"Success",0,0);
   2239          				//@English
   2240          			}
   2241          		}
   2242          		else
   2243          		{
   2244          			if (key == KEY_GPRS_S2)
   2245          			{
   2246          				gui_TextOut_ext(CENTER_ALIGN,39,"失败",0,0);
   2247          			}
   2248          			else
   2249          			{
   2250          				gui_TextOut_ext(CENTER_ALIGN,39,"成功",0,0);
   2251          			}
   2252          		}
   2253          	}
   2254          	else if (key == KEY_GPRS_S3)
   2255          	{
   2256          		if (LANG_ENGLISH == g_param.language)
   2257          		{
   2258          			gui_TextOut_ext(CENTER_ALIGN,26,"USB link disconnected",0,0);
   2259          			//@English
   2260          		}
   2261          		else
   2262          		{
   2263          			gui_TextOut_ext(CENTER_ALIGN,26,"USB连接断开了",0,0);
   2264          		}
   2265          	}
   2266          	else if(key == KEY_GPRS_S4)
   2267          	{
   2268          		if (LANG_ENGLISH == g_param.language)
   2269          		{
   2270          			gui_TextOut_ext(CENTER_ALIGN,26,"Command Error",0,0);
   2271          			//@English
   2272          		}
   2273          		else
   2274          		{
   2275          			gui_TextOut_ext(CENTER_ALIGN,26,"命令数据域错误",0,0);
   2276          		}
   2277          	}
   2278          	else if(key == KEY_GPRS_S7)
   2279          	{
   2280          		if (LANG_ENGLISH == g_param.language)
   2281          		{
   2282          			gui_TextOut_ext(CENTER_ALIGN,26,"Connect USB link...",0,0);
   2283          			//@English
   2284          		}
   2285          		else
   2286          		{
   2287          			gui_TextOut_ext(CENTER_ALIGN,26,"请连接USB...",0,0);
   2288          		}
   2289          	}
   2290          	else if (key == KEY_GPRS_S6)
   2291          	{
   2292          		if (LANG_ENGLISH == g_param.language)
   2293          		{
   2294          			gui_TextOut_ext(CENTER_ALIGN,26,"Command Timeout!",0,0);
   2295          			//@English
   2296          		}
   2297          		else
   2298          		{
   2299          			gui_TextOut_ext(CENTER_ALIGN,26,"等待主机命令超时",0,0);
   2300          		}
   2301          	}
   2302          
   2303          	gui_refresh(0,0,LCD_WIDTH,LCD_HEIGHT);
   2304          
   2305          	OSTimeDlyHMSM(0,0,1,500);
   2306          }
   2307          
   2308          void data_trans_proc_callback(void)
   2309          {
   2310          	//int		key;//command; 
   2311          
   2312          	if (OP_CODE_CONNECT == op_code)
   2313          	{
   2314          		gui_FillRect(0,ICON_HEIGHT+1,GUI_WIDTH,USERZONE_HEIGHT-1,BG_COLOR,0);
   2315          		if (LANG_ENGLISH == g_param.language)
   2316          		{
   2317          			gui_TextOut_ext(CENTER_ALIGN,26,"Download database...",0,0);
   2318          			//@English
   2319          		}
   2320          		else
   2321          		{
   2322          			gui_TextOut_ext(CENTER_ALIGN,26,"正在下载数据库...",0,0);
   2323          		}
   2324          
   2325          		gui_refresh(0,0,LCD_WIDTH,LCD_HEIGHT);
   2326          	}
   2327          
   2328          	return;
   2329          }
   2330          /**
   2331          ***************************************************************************
   2332          *@brief 数据导入导出的后台任务
   2333          *@param[in] 
   2334          *@return 
   2335          *@warning
   2336          *@see	
   2337          *@note  此函数无法判断应用层所需要的实际功能是否执行成功，因为命令都是由PC
   2338          *		主动发起的，是否成功只有PC上的应用程序才知道，所以需要PC在最后的断
   2339          *		开命令中返回此次的会话结果。
   2340          ***************************************************************************
   2341          */
   2342          static int data_trans_task(int param1, int param2, void *param3, void *param4)
   2343          {
   2344          	int				command,ret;
   2345          	int				data_trans_start_flag = 0;
   2346          	unsigned int	last_state = 0xff;
   2347          	unsigned int	last_cmd_status = 0xff;
   2348          	unsigned int	delay_cnt;
   2349          
   2350          	data_trans_state	= 0;
   2351          	while(1)
   2352          	{
   2353          		if(0 == task_read_command_from_ui(&command,0))
   2354          		{
   2355          			if (0 == data_trans_start_flag)
   2356          			{
   2357          				//还没有开始数据传输，用户按了取消键需要退出任务
   2358          				//如果已经开始与主机传输数据，不允许用户按取消键退出任务
   2359          				if (TASK_EXIT == command)
   2360          				{
   2361          					//用户按了取消键
   2362          					return KEY_EXT_1;
   2363          				}
   2364          			}
   2365          		}
   2366          
   2367          		if (bDeviceState == CONFIGURED)
   2368          		{
   2369          			//终端实现的USB设备已经被PC枚举成功
   2370          			if (last_state != bDeviceState)
   2371          			{
   2372          				reset_command();						//USB中断开始接收PC发送下来的命令
   2373          			}
   2374          
   2375          			////开始计时，检测是否命令超时
   2376          			if (last_cmd_status != g_pcCommand.status)
   2377          			{
   2378          				//StartDelay(200*120);		//2分钟的命令等待超时
   2379          				delay_cnt = 8000;
   2380          			}
   2381          
   2382          			if (g_pcCommand.status)
   2383          			{
   2384          				//接收到主机发送下来的命令
   2385          				data_trans_start_flag = 1;		//已经开始数据传输了
   2386          				no_update_icon_flg = 1;
   2387          				ret = data_transfer_proc(g_pcCommand.CmdBuffer,param1,data_trans_proc_callback); 
   2388          				no_update_icon_flg = 0;
   2389          				update_icon_cnt = 0;
   2390          				if (0 == ret)
   2391          				{
   2392          					data_trans_state = 1;
   2393          					reset_command();				//准备接收下一个命令
   2394          					last_cmd_status = 0xff;
   2395          					continue;
   2396          				}
   2397          				else if(1 == ret)
   2398          				{
   2399          					//接收到主机发送的断开命令，并且会话成功
   2400          					return KEY_GPRS_S1;		//会话成功
   2401          				}
   2402          				else if (2 == ret)
   2403          				{
   2404          					//接收到主机发送的断开命令，但是会话失败
   2405          					return KEY_GPRS_S2;			//会话失败
   2406          				}
   2407          				else if (0x55aa == ret)
   2408          				{
   2409          					//与HOST的USB连接断开
   2410          					return KEY_GPRS_S3;		//USB连接断开了
   2411          				}
   2412          				else   //if (ret)
   2413          				{
   2414          					//命令数据有误，终端没有响应
   2415          					return KEY_GPRS_S4;		//命令数据有误
   2416          				}	
   2417          			}
   2418          			else
   2419          			{
   2420          				delay_cnt--;
   2421          				//还没有接收到PC发送过来的命令
   2422          				if ((last_cmd_status != g_pcCommand.status)&&(data_trans_start_flag != 1))
   2423          				{
   2424          					task_send_command_to_ui(KEY_GPRS_S5);	
   2425          				}
   2426          
   2427          				//if (DelayIsEnd() == 0)
   2428          				if (delay_cnt == 0)
   2429          				{
   2430          					//等待主机命令超时
   2431          					return KEY_GPRS_S6;
   2432          				}
   2433          			}
   2434          
   2435          			last_cmd_status = g_pcCommand.status;
   2436          			last_state = bDeviceState;
   2437          		}
   2438          		else
   2439          		{
   2440          			//终端还没有接入主机的USB接口或者还没有枚举成功
   2441          			if (last_state != bDeviceState)
   2442          			{
   2443          				if(data_trans_start_flag)
   2444          				{
   2445          					return KEY_GPRS_S3;		//任务返回，提示前台“USB连接被断开了”
   2446          				}
   2447          				else
   2448          				{
   2449          					task_send_command_to_ui(KEY_GPRS_S7);	//通知主机刷新界面显示
   2450          				}
   2451          			}
   2452          			last_state = bDeviceState;
   2453          
   2454          			last_cmd_status = 0xff;
   2455          			USB_Cable_Config(0);
   2456          			Delay(5000);
   2457          			USB_Cable_Config(1);
   2458          			usb_cable_state = 1;
   2459          			OSTimeDlyHMSM(0,0,1,500);
   2460          		}
   2461          		OSTimeDlyHMSM(0,0,0,1);
   2462          	}
   2463          }
   2464          
   2465          
   2466          /**
   2467          ***************************************************************************
   2468          *@brief 数据导入导出功能的回调函数
   2469          *@param[in] 
   2470          *@return 
   2471          *@warning
   2472          *@see	
   2473          *@note 
   2474          ***************************************************************************
   2475          */
   2476          static unsigned char dlgproc_import_database(unsigned char type,unsigned char *key)
   2477          {
   2478          	if (DLGCB_CREATE == type)
   2479          	{
   2480          		g_mass_storage_device_type = MASSTORAGE_DEVICE_TYPE_DUMMY_FAT;
   2481          		usb_device_init(USB_MASSSTORAGE);	//将设备初始化为一个Masstorage设备
   2482          		USB_Cable_Config(1);
   2483          		usb_cable_state = 1;
   2484          		vcom_device_state = 0;
   2485          
   2486          		tmp_op_timeout = g_param.operate_timeout;
   2487          		g_param.operate_timeout = 0xFF;
   2488          		scan_start = 0;
   2489          	}
   2490          
   2491          	if (DLGCB_DRAW == type)
   2492          	{
   2493          		dlg_run_bgtask(data_trans_task,0,0,0,0);
   2494          	}
   2495          
   2496          	if (DLGCB_RUN == type)
   2497          	{
   2498          		if (KEY_ESC == *key || KEY_RIGHT_SHOTCUT == *key)
   2499          		{
   2500          			ui_send_command_to_task(TASK_EXIT);
   2501          			return RUN_RERUN;
   2502          		}
   2503          
   2504          		if ((KEY_GPRS_S6 == *key) || (KEY_GPRS_S7 == *key) || (KEY_GPRS_S4 == *key) || (KEY_GPRS_S2 == *key) || (KEY_GPRS_S3 == *key))
   2505          		{
   2506          			display_hh_result(hh_type,*key);
   2507          			if (*key == KEY_GPRS_S7)
   2508          			{
   2509          				return RUN_RERUN;
   2510          			}
   2511          			*key = KEY_ESC;
   2512          			return RUN_NEXT;
   2513          		}
   2514          		else if (KEY_EXT_1 == *key)
   2515          		{
   2516          			*key = KEY_ESC;
   2517          			return RUN_NEXT;
   2518          		}
   2519          		else if (KEY_ENTER == *key)
   2520          		{
   2521          			return RUN_RERUN;
   2522          		}
   2523          		else if (KEY_GPRS_S5 == *key)
   2524          		{
   2525          			//刷新显示
   2526          			gui_FillRect(0,ICON_HEIGHT+1,GUI_WIDTH,USERZONE_HEIGHT-1,BG_COLOR,0);
   2527          			if (LANG_ENGLISH == g_param.language)
   2528          			{
   2529          				gui_TextOut_ext(CENTER_ALIGN,26,"Waiting command...",0,0);
   2530          				//@English
   2531          			}
   2532          			else
   2533          			{
   2534          				gui_TextOut_ext(CENTER_ALIGN,26,"等待主机命令...",0,0);
   2535          			}
   2536          
   2537          			gui_refresh(0,0,LCD_WIDTH,LCD_HEIGHT);
   2538          			return RUN_RERUN;
   2539          		}
   2540          		else if (KEY_GPRS_S1 == *key)
   2541          		{
   2542          			display_hh_result(hh_type,KEY_GPRS_S1);
   2543          			*key = KEY_ESC;
   2544          			return RUN_NEXT;
   2545          		}
   2546          	}
   2547          
   2548          	if (DLGCB_DESTORY == type)
   2549          	{
   2550          		g_param.operate_timeout = tmp_op_timeout;
   2551          		device_init_by_setting();
   2552          	}
   2553          
   2554          	return RUN_CONTINUE;
   2555          }
   2556          
   2557          
   2558          /**
   2559          * @brief 条码设置选项
   2560          */
   2561          static unsigned char dlgproc_barcode_option(unsigned char type,unsigned char *key)
   2562          {
   2563          	return proc_list_menu(type,key);
   2564          }
   2565          
   2566          /**
   2567          * @brief 时间日期设置菜单
   2568          */
   2569          static unsigned char dlgproc_time_date_setting(unsigned char type,unsigned char *key)
   2570          {
   2571          	unsigned char input_time[15];
   2572          
   2573          	if (DLGCB_RUN == type)
   2574          	{
   2575          		if (KEY_LEFT_SHOTCUT == *key)
   2576          		{
   2577          			return RUN_EDIT_PROC;
   2578          		}
   2579          
   2580          		if (KEY_RIGHT_SHOTCUT == *key)
   2581          		{
   2582          			// 取得编辑框值
   2583          			if(g_dlg.edit.now[0] != g_dlg.edit.input_max[0])
   2584          			{
   2585          				return RUN_RERUN;
   2586          			}
   2587          
   2588          			//键值转换为字符串
   2589          			edit_etos(g_editValue[0],input_time,g_dlg.edit.now[0]);
   2590          			/** @note 在此检查输入的时间是否不符合格式		*/
   2591          			if(check_time(input_time) == 0)
   2592          			{
   2593          				SetDateTime();
   2594          				*key = KEY_ESC;
   2595          				return					RUN_NEXT;
   2596          			}
   2597          			gui_FillRect(0,ICON_HEIGHT+1,GUI_WIDTH,USERZONE_HEIGHT,BG_COLOR,0);
   2598          			if (LANG_ENGLISH == g_param.language)
   2599          			{
   2600          				gui_TextOut_ext(CENTER_ALIGN,13,"Invalid Time!",0,0);
   2601          				gui_TextOut_ext(CENTER_ALIGN,26,"Re-input!",0,0);
   2602          				//@English
   2603          			}
   2604          			else
   2605          			{
   2606          				gui_TextOut_ext(CENTER_ALIGN,13,"输入时间不合法!",0,0);
   2607          				gui_TextOut_ext(CENTER_ALIGN,16,"请重新输入",0,0);
   2608          			}
   2609                                  gui_refresh(0,0,LCD_WIDTH,LCD_HEIGHT);
   2610          			task_exit_flag = 1;
   2611          			OSTimeDlyHMSM(0,0,1,500);
   2612          			task_exit_flag = 0;
   2613          			return RUN_RETURN;
   2614          		}
   2615          	}
   2616          
   2617          	return RUN_CONTINUE;
   2618          }
   2619          
   2620          /**
   2621          * @brief 恢复默认设置
   2622          */
   2623          static unsigned char dlgproc_default_setting(unsigned char type,unsigned char *key)
   2624          {
   2625          	if (DLGCB_DRAW == type)
   2626          	{
   2627          		if (g_param.language == LANG_ENGLISH)
   2628          		{
   2629          			gui_TextOut(0,13,"The operate will clear all the data,Continue?",0,1);
   2630          		}
   2631          		else
   2632          		{
   2633          			gui_TextOut(0,13,"恢复默认设置将清除所有数据,是否继续?",0,1);
   2634          		}
   2635          	}
   2636          
   2637          	if (DLGCB_RUN == type)
   2638          	{
   2639          		if (KEY_LEFT_SHOTCUT == *key || KEY_ESC == *key)
   2640          		{
   2641          			*key = KEY_ESC;
   2642          			return RUN_NEXT;
   2643          		}
   2644          
   2645          		if (KEY_RIGHT_SHOTCUT == *key)
   2646          		{
   2647          			record_clear(REC_TYPE_CHECK);
   2648          			record_clear(REC_TYPE_BATCH);
   2649          			DefaultTerminalPara();
   2650          
   2651          			*key = KEY_ESC;
   2652          			return RUN_NEXT;
   2653          		}
   2654          	}
   2655          
   2656          	return RUN_CONTINUE;
   2657          }
   2658          
   2659          /**
   2660          * @brief 设置系统密码
   2661          */
   2662          static unsigned char dlgproc_set_system_password(unsigned char type,unsigned char *key)
   2663          {
   2664          	//todo.....
   2665          
   2666          	return RUN_CONTINUE;
   2667          }
   2668          
   2669          //刷新当前显示的解码器开关的开关情况
   2670          static void refresh_decoder_switch_map(unsigned char mode,unsigned char refresh_flag)
   2671          {
   2672          	unsigned char i = 0;
   2673          
   2674          	while (display_menu_item_array[i])
   2675          	{
   2676          		if (mode)
   2677          		{
   2678          			if (display_menu_item_array[i] == menu_current_item)
   2679          			{
   2680          				if (g_param.decoder_switch_map & (0x0001 << (display_menu_item_array[i] - 1)))
   2681          				{
   2682          					gui_PictureOut(GUI_WIDTH - 24,ICON_HEIGHT+1+i*13,PIC_GOU,1);
   2683          				}
   2684          				else
   2685          				{
   2686          					gui_FillRect(GUI_WIDTH - 24,ICON_HEIGHT+1+i*13,24,13,BG_COLOR,1);
   2687          				}
   2688                                          break;
   2689          			}
   2690          		}
   2691          		else
   2692          		{
   2693          			if (g_param.decoder_switch_map & (0x0001 << (display_menu_item_array[i] - 1)))
   2694          			{
   2695          				gui_PictureOut(GUI_WIDTH - 24,ICON_HEIGHT+1+i*13,PIC_GOU,1);
   2696          			}
   2697          			else
   2698          			{
   2699          				gui_FillRect(GUI_WIDTH - 24,ICON_HEIGHT+1+i*13,24,13,BG_COLOR,1);
   2700          			}
   2701          		}
   2702          		i++;
   2703          	}
   2704          }
   2705          
   2706          /**
   2707          * @brief 设置解码器
   2708          */
   2709          static unsigned char dlgproc_decoder_setting(unsigned char type,unsigned char *key)
   2710          {	
   2711          	static unsigned short map_save;
   2712          
   2713          	if (DLGCB_DRAW == type)
   2714          	{
   2715          		//显示当前设置的解码器选项
   2716          		refresh_decoder_switch_map(0,1);
   2717          		map_save = g_param.decoder_switch_map;
   2718          	}
   2719          
   2720          	if (DLGCB_RUN == type)
   2721          	{
   2722          		if (KEY_ENTER == *key || KEY_SCAN == *key)
   2723          		{
   2724          			g_param.decoder_switch_map ^= (0x0001 << menu_current_item - 1);
   2725          			refresh_decoder_switch_map(1,1);
   2726          			return RUN_RERUN;
   2727          		}
   2728          	}
   2729          
   2730          	if (DLGCB_PAGECHANGE == type)
   2731          	{
   2732          		refresh_decoder_switch_map(0,1);
   2733          	}
   2734          
   2735          	if (DLGCB_DESTORY == type)
   2736          	{
   2737          		if (map_save != g_param.decoder_switch_map)
   2738          		{
   2739          			SaveTerminalPara();
   2740          			UE988_set_decoder_switch(g_param.decoder_switch_map);
   2741          		}	
   2742          	}
   2743          
   2744          	return RUN_CONTINUE;
   2745          }
   2746          
   2747          /**
   2748          * @brief 设置解码有效位数
   2749          */
   2750          static unsigned char dlgproc_invalid_offset_setting(unsigned char type,unsigned char *key)
   2751          {
   2752          	unsigned char str[4];
   2753          
   2754          	if (DLGCB_CREATE == type)
   2755          	{
   2756          		valid_barcode_start_offset_tmp = g_param.valid_barcode_start_offset;
   2757          		valid_barcode_end_offset_tmp   = g_param.valid_barcode_end_offset;
   2758          
   2759          	}
   2760          	if (DLGCB_DRAW == type)
   2761          	{
   2762          		if ((g_param.valid_barcode_start_offset != 0xff)||(g_param.valid_barcode_end_offset != 0xff))
   2763          		{
   2764          			edit_itoa(valid_barcode_start_offset_tmp,str);
   2765          			edit_setvalue(&g_dlg.edit,str,0);	
   2766          
   2767          			edit_itoa(valid_barcode_end_offset_tmp,str);
   2768          			edit_setvalue(&g_dlg.edit,str,1);	
   2769          		}
   2770          	}
   2771          
   2772          	if ((DLGCB_RUN == type)&&(task_exit_flag == 0))
   2773          	{
   2774          		if (KEY_ESC == *key || KEY_RIGHT_SHOTCUT == *key)
   2775          		{
   2776          			if ((g_dlg.edit.now[0] == 0) && (g_dlg.edit.now[1] == 0))
   2777          			{
   2778          				g_param.valid_barcode_end_offset	= 0xff;
   2779          				g_param.valid_barcode_start_offset  = 0xff;
   2780          			}
   2781          			else
   2782          			{
   2783          				if((g_dlg.edit.now[0] == 0) || (g_dlg.edit.now[1] == 0))
   2784          				{
   2785          					return RUN_RERUN;
   2786          				}
   2787          				else
   2788          				{
   2789          					valid_barcode_start_offset_tmp =   edit_atoi(g_editValue[0]);
   2790          					valid_barcode_end_offset_tmp   =   edit_atoi(g_editValue[1]);
   2791          
   2792          					if ((valid_barcode_end_offset_tmp > 30) || (valid_barcode_start_offset_tmp > 30)
   2793          						|| (valid_barcode_end_offset_tmp <= valid_barcode_start_offset_tmp)
   2794          						|| (valid_barcode_start_offset_tmp < 1) )
   2795          					{
   2796          						gui_FillRect(0,ICON_HEIGHT+1,GUI_WIDTH,USERZONE_HEIGHT,BG_COLOR,1);	
   2797          
   2798          						if (LANG_ENGLISH == g_param.language)
   2799          						{
   2800          							gui_TextOut_ext(CENTER_ALIGN,13,"Invalid setting",0,1);
   2801          							gui_TextOut_ext(CENTER_ALIGN,26,"Re-input!",0,1);
   2802          							//@English
   2803          						}
   2804          						else
   2805          						{
   2806          							gui_TextOut_ext(CENTER_ALIGN,13,"设置无效",0,1);
   2807          							gui_TextOut_ext(CENTER_ALIGN,26,"请重新输入!",0,1);
   2808          						}
   2809          						task_exit_flag = 1;
   2810          						OSTimeDlyHMSM(0,0,1,0);
   2811          						task_exit_flag = 0;
   2812          						return RUN_RETURN;
   2813          					}
   2814          					g_param.valid_barcode_start_offset = valid_barcode_start_offset_tmp;
   2815          					g_param.valid_barcode_end_offset   = valid_barcode_end_offset_tmp;
   2816          
   2817          				}
   2818          
   2819          			}
   2820          			*key = KEY_ESC;
   2821          			SaveTerminalPara();
   2822          			return RUN_NEXT;
   2823          		}
   2824          
   2825          		if (KEY_LEFT_SHOTCUT == *key)
   2826          		{
   2827          			return RUN_EDIT_PROC;
   2828          		}
   2829          
   2830          	}
   2831          	return RUN_CONTINUE;
   2832          }
   2833          
   2834          
   2835          /**
   2836          * @brief 查看内存信息
   2837          */
   2838          static unsigned char dlgproc_view_memery(unsigned char type,unsigned char *key)
   2839          {
   2840          	unsigned int cnt;
   2841          	unsigned char str[51];
   2842          	FATFS		*fs;
   2843          
   2844          	if (DLGCB_DRAW == type)
   2845          	{
   2846          		if(f_getfree("/",&cnt,&fs) == FR_OK)
   2847          		{
   2848          			if (g_param.language == LANG_ENGLISH)
   2849          			{
   2850          				sprintf(str,"Remain %d free bytes,used %d bytes",cnt*512,8*1024*1024-(cnt*512));
   2851          			}
   2852          			else
   2853          			{
   2854          				sprintf(str,"剩余%d可用字节,已占用%d字节",cnt*512,8*1024*1024-(cnt*512));
   2855          			}
   2856          
   2857          			gui_TextOut(0,13,str,0,1);
   2858          		}
   2859          	}
   2860          	return RUN_CONTINUE;
   2861          }
   2862          
   2863          
   2864          /**
   2865          * @brief 查看蓝牙信息
   2866          */
   2867          static unsigned char dlgproc_bluetooth_info(unsigned char type,unsigned char *key)
   2868          {
   2869          	if (DLGCB_DRAW == type)
   2870          	{
   2871          		if (g_param.language == LANG_ENGLISH)
   2872          		{
   2873          			gui_TextOut(0,13,"KeyboardName:LSBTK001",0,1);
   2874          			gui_TextOut(0,26,"ProtocolVer:V2.0",0,1);
   2875          		}
   2876          		else
   2877          		{
   2878          			gui_TextOut(0,13,"蓝牙键盘名称:LSBTK001",0,1);
   2879          			gui_TextOut(0,26,"蓝牙协议版本:V2.0",0,1);
   2880          		}
   2881          	}
   2882          	return RUN_CONTINUE;
   2883          }
   2884          
   2885          /**
   2886          * @brief 查看固件信息
   2887          */
   2888          static unsigned char dlgproc_firmware_info(unsigned char type,unsigned char *key)
   2889          {
   2890          	unsigned char str[21];
   2891          
   2892          	if (DLGCB_DRAW == type)
   2893          	{
   2894          		if (g_param.language == LANG_ENGLISH)
   2895          		{
   2896          			gui_TextOut(0,13,"Firmware:V1.0.0",0,1);
   2897          			strcpy(str,"App Ver:");
   2898          			strcat(str,app_ver);
   2899          			gui_TextOut(0,26,str,0,1);
   2900          			gui_TextOut(0,39,"Scanner:uE_2.3_1.5.29",0,1);
   2901          		}
   2902          		else
   2903          		{
   2904          			gui_TextOut(0,13,"固件版本:V1.0.0",0,1);
   2905          			strcpy(str,"应用版本:");
   2906          			strcat(str,app_ver);
   2907          			gui_TextOut(0,26,str,0,1);
   2908          			gui_TextOut(0,39,"扫描头:uE_2.3_1.5.29",0,1);
   2909          		}
   2910          	}
   2911          	return RUN_CONTINUE;
   2912          }
   2913          
   2914          
   2915          /**
   2916          * @brief 创建新文件
   2917          */
   2918          static unsigned char dlgproc_create_new_file(unsigned char type,unsigned char *key)
   2919          {
   2920          	unsigned char str[13];
   2921          
   2922          	if (DLGCB_RUN == type)
   2923          	{
   2924          		if ((KEY_LEFT_SHOTCUT == *key)&&(task_exit_flag == 0))
   2925          		{
   2926          			return RUN_EDIT_PROC;
   2927          		}
   2928          
   2929          		if ((KEY_ENTER == *key || KEY_SCAN == *key)&&(task_exit_flag == 0))
   2930          		{
   2931          			if(g_dlg.edit.now[0] == 0)
   2932          			{
   2933          				return RUN_RERUN;
   2934          			}
   2935          			
   2936          			strcpy(str,g_editValue[0]);
   2937          			strcat(str,".txt");
   2938          			
   2939          			gui_FillRect(0,13,GUI_WIDTH,USERZONE_HEIGHT,BG_COLOR,0);
   2940          
   2941          			if (f_open(&file2,(const unsigned char*)str,FA_CREATE_NEW) != FR_OK)
   2942          			{
   2943          				
   2944          				Beep(BEEP_DELAY*2);
   2945          				if (g_param.language == LANG_ENGLISH)
   2946          				{
   2947          					gui_TextOut_ext(CENTER_ALIGN,26,"Create file fail!",0,0);
   2948          				}
   2949          				else
   2950          				{
   2951          					gui_TextOut_ext(CENTER_ALIGN,26,"文件创建失败!",0,0);
   2952          				}
   2953          			}
   2954          			else
   2955          			{
   2956          				if (g_param.language == LANG_ENGLISH)
   2957          				{
   2958          					gui_TextOut_ext(CENTER_ALIGN,26,"Create file success!",0,0);
   2959          				}
   2960          				else
   2961          				{
   2962          					gui_TextOut_ext(CENTER_ALIGN,26,"文件创建成功!",0,0);
   2963          				}
   2964          				f_close(&file2);
   2965          			}
   2966          			gui_refresh(0,0,LCD_WIDTH,LCD_HEIGHT);
   2967          			task_exit_flag = 1;
   2968          			OSTimeDlyHMSM(0,0,1,0);
   2969          			task_exit_flag = 0;
   2970          			*key = KEY_ENTER;
   2971          			return RUN_NEXT;
   2972          		}
   2973          
   2974          		if ((KEY_RIGHT_SHOTCUT == *key || KEY_ESC == *key)&&(task_exit_flag == 0))
   2975          		{
   2976          			*key = KEY_ESC;
   2977          			return RUN_NEXT;
   2978          		}
   2979          	}
   2980          
   2981          	if (DLGCB_BACK_FROM_VIRTUAL_KEYPAD == type)
   2982          	{
   2983          		if (KEY_LEFT_SHOTCUT == *key)
   2984          		{
   2985          			//检查是否包含了非法字符
   2986          			strcpy(str,g_editValue[0]);
   2987          			if ((strstr(str,"*") != NULL)||(strstr(str,"\\") != NULL)||(strstr(str,"|") != NULL)||(strstr(str,"\"") != NULL)\
   2988                                      ||(strstr(str,"/") != NULL)||(strstr(str,"?") != NULL)||(strstr(str,">") != NULL)||(strstr(str,"<") != NULL)\
   2989                                       ||(strstr(str,".") != NULL))
   2990          			{
   2991          				memset(g_editValue[0],0,MAX_EDITNUM);
   2992          				gui_FillRect(0,0,GUI_WIDTH,LCD_HEIGHT,BG_COLOR,0);
   2993          				Beep(BEEP_DELAY*2);
   2994          				gui_TextOut(0,26,"不允许包含非法字符!",0,0);
   2995          				gui_refresh(0,0,LCD_WIDTH,LCD_HEIGHT);
   2996          				OSTimeDlyHMSM(0,0,1,0);
   2997          				gui_TextOut(0,26,"                    ",0,1);
   2998          				*key = KEY_EXT_1;
   2999          				return RUN_NEXT;
   3000          			}
   3001          		}
   3002          	}
   3003          
   3004          	return RUN_CONTINUE;
   3005          }
   3006          
   3007          //扫描根目录下的TXT文件,最多支持20个TXT文件
   3008          static unsigned char  scan_files(unsigned char *pfn_List)
   3009          {
   3010          	FRESULT res;
   3011          	FILINFO fno;
   3012          	DIR dir;
   3013          	unsigned char i = 0;
   3014          
   3015          	res = f_opendir(&dir, "/");
   3016          	if (res == FR_OK) {
   3017          		for (;;) {
   3018          			res = f_readdir(&dir, &fno);
   3019          			if (res != FR_OK || fno.fname[0] == 0) break;
   3020          			if (fno.fname[0] == '.') continue;
   3021          			if (strstr(fno.fname,".txt") == NULL && strstr(fno.fname,".TXT") == NULL)	continue;
   3022          			if (fno.fattrib & AM_DIR) continue;
   3023          			
   3024          			strcpy(pfn_List+13*i,fno.fname);
   3025          			i++;
   3026          
   3027          			if (i == 21)
   3028          			{
   3029          				break;
   3030          			}
   3031          		}
   3032          	}
   3033          	return i;
   3034          }
   3035          
   3036          static unsigned char current_select_file[13];
   3037          
   3038          //刷新显示文件列表，返回当前选择的文件索引
   3039          static void refresh_file_list(unsigned char *plist,unsigned char list_cnt,unsigned char key)
   3040          {
   3041          	static unsigned char start_display_offset;
   3042          	static unsigned char current_offset;
   3043          	unsigned char i;
   3044          
   3045          	if (list_cnt == 0)
   3046          	{
   3047          		return;
   3048          	}
   3049          
   3050          	if (key == 0)
   3051          	{
   3052          		start_display_offset = 0;
   3053          		current_offset = 0;
   3054          	}
   3055          	else if( KEY_DOWN == key)
   3056          	{	
   3057          		// 下翻页
   3058          		if (current_offset == (list_cnt-1))
   3059          		{
   3060          			current_offset = 0;
   3061          			start_display_offset = 0;
   3062          		}
   3063          		else
   3064          		{
   3065          			current_offset++;
   3066          			if (current_offset == (start_display_offset+3))
   3067          			{
   3068          				start_display_offset ++;
   3069          			}
   3070          		}
   3071          	}
   3072          	else if(KEY_UP == key)
   3073          	{	// 上翻页
   3074          		if (current_offset == 0)
   3075          		{
   3076          			current_offset = list_cnt-1;
   3077          			start_display_offset = list_cnt - 3;
   3078          		}
   3079          		else
   3080          		{
   3081          			current_offset--;
   3082          			if (current_offset < start_display_offset)
   3083          			{
   3084          				start_display_offset--;
   3085          			}
   3086          		}
   3087          	}
   3088          	else if (KEY_ENTER == key || KEY_SCAN == key)
   3089          	{
   3090          		strcpy(g_param.u_disk_storage_file,plist+(start_display_offset+current_offset)*13);
   3091          	}
   3092          
   3093          	gui_FillRect(0,13,GUI_WIDTH,USERZONE_HEIGHT,BG_COLOR,0);
   3094          	for (i = 0; i < 3;i++)
   3095          	{
   3096          		if ((start_display_offset+i) == list_cnt)
   3097          		{
   3098          			break;
   3099          		}
   3100          
   3101          		if (current_offset == start_display_offset+i)
   3102          		{
   3103          			gui_SetTextColor(BG_COLOR);
   3104          			strcpy(current_select_file,plist+(start_display_offset+current_offset)*13);
   3105          		}
   3106          		else
   3107          		{
   3108          			gui_SetTextColor(TXT_COLOR);
   3109          		}
   3110          
   3111          		gui_TextOut(0,13+13*i,plist+(start_display_offset+i)*13,0,0);
   3112          
   3113          		if (strcmp(g_param.u_disk_storage_file,plist+(start_display_offset+i)*13) == 0)
   3114          		{
   3115          			gui_PictureOut(GUI_WIDTH - 24,ICON_HEIGHT+1+i*13,PIC_GOU,0);
   3116          		}
   3117          	}
   3118          	gui_refresh(0,0,LCD_WIDTH,LCD_HEIGHT);
   3119          	gui_SetTextColor(TXT_COLOR);
   3120          }
   3121          /**
   3122          * @brief 显示文件列表
   3123          */
   3124          static unsigned char dlgproc_file_list(unsigned char type,unsigned char *key)
   3125          {
   3126          	static unsigned char *pList;
   3127          	static unsigned char file_cnt = 0;
   3128          
   3129          	if (DLGCB_CREATE == type)
   3130          	{
   3131          		pList = (unsigned char*)Jmalloc(13*21);
   3132          		if (pList)
   3133          		{
   3134          			file_cnt = scan_files(pList);
   3135          		}
   3136          	}
   3137          
   3138          	if (DLGCB_DRAW == type)
   3139          	{
   3140          		refresh_file_list(pList,file_cnt,0);
   3141          	}
   3142          
   3143          	if (DLGCB_RUN == type)
   3144          	{
   3145          		if (KEY_UP == *key || KEY_DOWN == *key || KEY_ENTER == *key || KEY_SCAN == *key)
   3146          		{
   3147          			refresh_file_list(pList,file_cnt,*key);
   3148          			return RUN_RERUN;
   3149          		}
   3150          
   3151          		if (KEY_ESC == *key || KEY_RIGHT_SHOTCUT == *key)
   3152          		{
   3153          			*key = KEY_ESC;
   3154          			SaveTerminalPara();
   3155          			return RUN_NEXT;
   3156          		}
   3157          
   3158          		if (KEY_LEFT_SHOTCUT == *key)
   3159          		{
   3160          			if (file_cnt == 0)
   3161          			{
   3162          				return RUN_RERUN;
   3163          			}
   3164          
   3165          			return RUN_NEXT;
   3166          		}
   3167          	}
   3168          
   3169          	if (DLGCB_DESTORY == type)
   3170          	{
   3171          		Jfree(pList);
   3172          	}
   3173          
   3174          	return RUN_CONTINUE;
   3175          }
   3176          
   3177          
   3178          /**
   3179          * @brief 格式化U DISK
   3180          */
   3181          static unsigned char dlgproc_u_disk_format(unsigned char type,unsigned char *key)
   3182          {
   3183          	if (DLGCB_DRAW == type)
   3184          	{
   3185          		if (g_param.language == LANG_ENGLISH)
   3186          		{
   3187          			gui_TextOut(0,13,"All the data will be cleared,Continue？",0,1);
   3188          		}
   3189          		else
   3190          		{
   3191          			gui_TextOut(0,13,"所有数据将丢失并不可恢复,是否继续?",0,1);
   3192          		}
   3193          	}
   3194          
   3195          	if (DLGCB_RUN == type)
   3196          	{
   3197          		if (KEY_LEFT_SHOTCUT == *key)
   3198          		{	
   3199          			gui_FillRect(0,13,GUI_WIDTH,USERZONE_HEIGHT,BG_COLOR,1);
   3200          			if (g_param.language == LANG_ENGLISH)
   3201          			{
   3202          				gui_TextOut(0,26,"Formatting...",0,1);
   3203          			}
   3204          			else
   3205          			{
   3206          				gui_TextOut(0,26,"正在格式化,请稍候...",0,1);
   3207          			}
   3208          			f_mkfs(0,1,512);
   3209          
   3210          			*key = KEY_ENTER;
   3211          			return RUN_NEXT;
   3212          		}
   3213          
   3214          		if (KEY_RIGHT_SHOTCUT == *key)
   3215          		{
   3216          			*key = KEY_ESC;
   3217          			return RUN_NEXT;
   3218          		}
   3219          	}
   3220          	return RUN_CONTINUE;
   3221          }
   3222          
   3223          /**
   3224          * @brief 文件操作选项
   3225          */
   3226          static unsigned char dlgproc_file_options_menu(unsigned char type,unsigned char *key)
   3227          {
   3228          	return proc_list_menu(type,key);
   3229          }
   3230          /**
   3231          * @brief 清空文件
   3232          */
   3233          static unsigned char dlgproc_clear_file_ack(unsigned char type,unsigned char *key)
   3234          {
   3235          	if (DLGCB_DRAW == type)
   3236          	{
   3237          		if (g_param.language == LANG_ENGLISH)
   3238          		{
   3239          			gui_TextOut(0,26,"Clear this file?",0,1);
   3240          		}
   3241          		else
   3242          		{
   3243          			gui_TextOut(0,26,"确定清空此文件?",0,1);
   3244          		}
   3245          	}
   3246          
   3247          	if (DLGCB_RUN == type)
   3248          	{
   3249          		if (KEY_LEFT_SHOTCUT == *key)
   3250          		{	
   3251          			if (f_open(&file2,current_select_file,FA_OPEN_EXISTING | FA_WRITE) != FR_OK)
   3252          			{
   3253          				gui_TextOut(0,26,"                    ",0,1);
   3254          				if (g_param.language == LANG_ENGLISH)
   3255          				{
   3256          					gui_TextOut(0,26,"Clear fail!",0,1);
   3257          				}
   3258          				else
   3259          				{
   3260          					gui_TextOut(0,26,"文件清空失败!",0,1);
   3261          				}
   3262          				Beep(BEEP_DELAY*2);
   3263          			}
   3264          
   3265          			f_lseek(&file2,0);
   3266          
   3267          			f_truncate(&file2);
   3268          
   3269          			f_close(&file2);
   3270                                  *key = KEY_ENTER;
   3271          			return RUN_NEXT;
   3272          		}
   3273          
   3274          		if (KEY_RIGHT_SHOTCUT == *key)
   3275          		{
   3276          			*key = KEY_ESC;
   3277          			return RUN_NEXT;
   3278          		}
   3279          	}
   3280          	return RUN_CONTINUE;
   3281          }
   3282          /**
   3283          * @brief 删除文件
   3284          */
   3285          static unsigned char dlgproc_delete_file_ack(unsigned char type,unsigned char *key)
   3286          {
   3287          
   3288          	if (DLGCB_DRAW == type)
   3289          	{
   3290          		if(strcmp(g_param.u_disk_storage_file,current_select_file) == 0)
   3291          		{
   3292          			if (g_param.language == LANG_ENGLISH)
   3293          			{
   3294          				gui_TextOut(0,26,"Can't Del target file",0,1);
   3295          			}
   3296          			else
   3297          			{
   3298          				gui_TextOut(0,26,"不能删除目标存储文件",0,1);
   3299          			}
   3300          			Beep(BEEP_DELAY*2);
   3301          			OSTimeDlyHMSM(0,0,1,0);
   3302          
   3303          			*key = KEY_ESC;
   3304          			return RUN_NEXT;
   3305          		}
   3306          
   3307          		if (g_param.language == LANG_ENGLISH)
   3308          		{
   3309          			gui_TextOut(0,26,"Delete this file?",0,1);
   3310          		}
   3311          		else
   3312          		{
   3313          			gui_TextOut(0,26,"确定删除此文件?",0,1);
   3314          		}
   3315          	}
   3316          
   3317          	if (DLGCB_RUN == type)
   3318          	{
   3319          		if (KEY_LEFT_SHOTCUT == *key)
   3320          		{	
   3321          			if (f_unlink(current_select_file) != FR_OK)
   3322          			{
   3323          				gui_TextOut(0,26,"                    ",0,1);
   3324          				if (g_param.language == LANG_ENGLISH)
   3325          				{
   3326          					gui_TextOut(0,26,"Delete fail!",0,1);
   3327          				}
   3328          				else
   3329          				{
   3330          					gui_TextOut(0,26,"文件删除失败!",0,1);
   3331          				}
   3332          				Beep(BEEP_DELAY*2);
   3333          			}
   3334                                  *key = KEY_ENTER;
   3335          			return RUN_NEXT;
   3336          		}
   3337          
   3338          		if (KEY_RIGHT_SHOTCUT == *key)
   3339          		{
   3340          			*key = KEY_ESC;
   3341          			return RUN_NEXT;
   3342          		}
   3343          	}
   3344          	return RUN_CONTINUE;
   3345          }
   3346          
   3347          /**
   3348          * @brief 初始化应用环境
   3349          */
   3350          static void app_init(void)
   3351          {
   3352          	dlg_refresh_flag = 0;
   3353          	no_update_icon_flg = 0;
   3354          	need_refresh_signal = 0;
   3355          	current_home_item = 1;
   3356          	menu_current_item = 1;
   3357          	menu_start = 1;
   3358          	memset(BarCode,0,31);
   3359          	//memset((void*)draw_content,0,MAX_CASH_ITEM*sizeof(TDRAW_ITEM));	//将缓存的内容清掉
   3360          
   3361          	if (g_param.transfer_mode == TRANSFER_MODE_BLUETOOTH)
   3362          	{
   3363          		bluetooth_match_cmd_cnt = 0;
   3364          		bluetooth_state_cnt = 0;
   3365          	}
   3366          
   3367          	InitDrawContext();
   3368          }
   3369          
   3370          void task_ui(void* pp)
   3371          {
   3372          	app_init();
   3373          	//gui_clear(BG_COLOR);
   3374          	gui_SetTextColor(TXT_COLOR);
   3375          	gui_setlanguage(g_param.language);
   3376          	max_dlg				= DLG_MAX;
   3377          	next_dlg_id			= DLG_logo;	
   3378          	dlg_loop();
   3379          }
   3380          
   3381          //根据设置对设备的状态进行初始化
   3382          void device_init_by_setting(void)
   3383          {
   3384          	if (g_param.transfer_mode == TRANSFER_MODE_BLUETOOTH)
   3385          	{
   3386          		USB_Cable_Config(0);		//断开USB设备的连接
   3387          		YFBT07_power_ctrl(1);		//开启蓝牙模块的电源
   3388          		bluetooth_match_cmd_cnt = 0;
   3389          		led_g_ctrl(1);
   3390          	}
   3391          	else if (g_param.transfer_mode == TRANSFER_MODE_KEYBOARD)
   3392          	{
   3393          		USB_Cable_Config(1);
   3394          		usb_device_init(USB_KEYBOARD);
   3395          		YFBT07_power_ctrl(0);	//关闭蓝牙模块的电源
   3396          		led_g_ctrl(0);
   3397          	}
   3398          	else if (g_param.transfer_mode == TRANSFER_MODE_VIRTUAL_COMM)
   3399          	{
   3400          		USB_Cable_Config(1);
   3401          		usb_device_init(USB_VIRTUAL_PORT);
   3402          		YFBT07_power_ctrl(0);	//关闭蓝牙模块的电源
   3403          		led_g_ctrl(0);
   3404          	}
   3405          	else if (g_param.transfer_mode == TRANSFER_MODE_U_DISK)
   3406          	{
   3407          		YFBT07_power_ctrl(0);	//关闭蓝牙模块的电源
   3408          		led_g_ctrl(0);
   3409          		g_mass_storage_device_type = MASSTORAGE_DEVICE_TYPE_SPI_FLASH;
   3410          		usb_device_init(USB_MASSSTORAGE);
   3411          		USB_Cable_Config(1);
   3412          	}
   3413          	else
   3414          	{
   3415          		if (g_param.batch_transfer_mode == TRANSFER_MODE_BLUETOOTH)
   3416          		{
   3417          			USB_Cable_Config(0);		//断开USB设备的连接
   3418          			YFBT07_power_ctrl(1);		//开启蓝牙模块的电源
   3419          			bluetooth_match_cmd_cnt = 0;
   3420          			led_g_ctrl(1);
   3421          		}
   3422          		else if (g_param.batch_transfer_mode == TRANSFER_MODE_KEYBOARD)
   3423          		{
   3424          			usb_device_init(USB_KEYBOARD);
   3425          			YFBT07_power_ctrl(0);	//关闭蓝牙模块的电源
   3426          			led_g_ctrl(0);
   3427          			USB_Cable_Config(1);
   3428          		}
   3429          		else
   3430          		{
   3431          			USB_Cable_Config(1);
   3432          			usb_device_init(USB_VIRTUAL_PORT);
   3433          			YFBT07_power_ctrl(0);	//关闭蓝牙模块的电源
   3434          			led_g_ctrl(0);
   3435          		}
   3436          	}
   3437          }
   3438          
   3439          void display_copyright_info(unsigned char state)
   3440          {
   3441          	unsigned char *str[6]={
   3442          		"\xe8\xa0\x9c\xed\x99\xa1\xe9\x9c\xf9\xe0\x90\xa7\xe4\x87\xe8\x93\xe6\xf5\x9c\xad",	//产品名称：数据采集器
   3443          		"\xE8\xA0\x9C\xED\x8A\x97\xE0\x9F\xF9\xE0\x0E\x6C",									//产品型号：T6
   3444          		"\x93\xA0\xE8\xA0\xE9\xFD\x93\x96\xF9\xE0\x93\xB4\x81\x80\x90\x8a\xe7\xf7\xe8\xf2\x9b\xa0\xef\xbd\x8d\x89\x89\x8a\x95\x84\xe3\xf1\x91\xe4",	//生产厂商：深圳市江波龙电子有限公司
   3445          		"\xEF\xBD\xE1\xEA\xF9\xE0\x6A\x6D\x6F\x6F\x77\x69\x68\x62\x69\x6B\x68\x69\x63",		//电话：0755-32831239
   3446          		"\x92\xb7\xe6\xa4\x8c\xa2\x8d\xad\x92\xf2\xea\xbc\x92\xf2\x91\xa3\x89\x8a",	//软件著作权版权所有
   3447          		"\x8b\x95\xe7\xa1\xef\x9b\xea\xbc\xf9\xf6\x94\xff\xed\xf2\xeb\x82\xe4\xe5\xf9\xfb",//严禁盗版，违法必究！
   3448          	};
   3449          
   3450          	unsigned char i,buffer[41];
   3451          
   3452          	gui_clear(0);
   3453          	if (state == 0)
   3454          	{	
   3455          		memset(buffer,0,41);
   3456          		for (i = 0;i < strlen(str[0]);i++)
   3457          		{
   3458          			buffer[i] = (*(str[0]+i))^0x5a;
   3459          		}
   3460          		gui_TextOut(0,0,buffer,0,0);
   3461          
   3462          		memset(buffer,0,41);
   3463          		for (i = 0;i < strlen(str[1]);i++)
   3464          		{
   3465          			buffer[i] = (*(str[1]+i))^0x5a;
   3466          		}
   3467          		gui_TextOut(0,13,buffer,0,0);
   3468          
   3469          		memset(buffer,0,41);
   3470          		for (i = 0;i < strlen(str[2]);i++)
   3471          		{
   3472          			buffer[i] = (*(str[2]+i))^0x5a;
   3473          		}
   3474          		gui_TextOut(0,26,buffer,0,0);
   3475          
   3476          		memset(buffer,0,41);
   3477          		for (i = 0;i < strlen(str[3]);i++)
   3478          		{
   3479          			buffer[i] = (*(str[3]+i))^0x5a;
   3480          		}
   3481          		gui_TextOut(0,52,buffer,0,0);
   3482          	}
   3483          
   3484          	if (state == 1)
   3485          	{
   3486          		memset(buffer,0,41);
   3487          		for (i = 0;i < strlen(str[4]);i++)
   3488          		{
   3489          			buffer[i] = (*(str[4]+i))^0x5a;
   3490          		}
   3491          		gui_TextOut(0,0,buffer,0,0);
   3492          
   3493          		memset(buffer,0,41);
   3494          		for (i = 0;i < strlen(str[5]);i++)
   3495          		{
   3496          			buffer[i] = (*(str[5]+i))^0x5a;
   3497          		}
   3498          		gui_TextOut(0,13,buffer,0,0);
   3499          	}
   3500          
   3501          	gui_refresh(0,0,LCD_WIDTH,LCD_HEIGHT);
   3502          }
   3503          
   3504          /**
   3505          * @brief 主界面回调函数，task_ui第一个运行起来的界面回调函数
   3506          */
   3507          static unsigned char dlgproc_about_copyright(unsigned char type,unsigned char *key)
   3508          {
   3509          	static unsigned char dlg_state = 0;
   3510          
   3511          	if (DLGCB_DRAW == type)
   3512          	{
   3513          		display_copyright_info(dlg_state);
   3514          	}
   3515          
   3516          	if (DLGCB_RUN == type)
   3517          	{
   3518          		if ((*key == KEY_UP)&&(dlg_state == 1))
   3519          		{
   3520          			dlg_state = 0;
   3521          			display_copyright_info(dlg_state);
   3522          			return RUN_RERUN;
   3523          		}
   3524          
   3525          		if ((*key == KEY_DOWN)&&(dlg_state == 0))
   3526          		{
   3527          			dlg_state = 1;
   3528          			display_copyright_info(dlg_state);
   3529          			return RUN_RERUN;
   3530          		}
   3531          	}
   3532          
   3533          	return RUN_CONTINUE;
   3534          }
   3535          
   3536          
   3537          //测试任务
   3538          static void enter_test_task(unsigned char test_type)
   3539          {
   3540          	unsigned int  i,success_cnt,fail_cnt;
   3541          	unsigned char *key = NULL;
   3542          	unsigned char code_value[31];
   3543          	unsigned char str[11];
   3544          	unsigned char transfer_mode_save;
   3545          
   3546          
   3547          	//OSSchedLock();	//不要再进行任务调度
   3548          	gui_clear(0);	//清屏
   3549          
   3550          	if (test_type == 1)
   3551          	{
   3552          		gui_TextOut(0,0,"条码(S):",0,1);
   3553          		gui_TextOut(0,26,"成功次数:",0,1);
   3554          		gui_TextOut(0,39,"错误次数:",0,1);
   3555          		success_cnt = fail_cnt = 0;
   3556          		memset(code_value,0,31);
   3557          	}
   3558          	else if (test_type == 2)
   3559          	{
   3560          		//将蓝牙模块强制打开
   3561          		transfer_mode_save = g_param.transfer_mode;
   3562          		g_param.transfer_mode = TRANSFER_MODE_BLUETOOTH;
   3563          		device_init_by_setting();
   3564          		gui_TextOut_ext(CENTER_ALIGN,13,"蓝牙模块已开启",0,1);
   3565          		gui_TextOut_ext(CENTER_ALIGN,26,"等待主机连接中...",0,1);
   3566          		success_cnt = 2;
   3567          		fail_cnt = 0x20;
   3568          		i = 1;
   3569          	}
   3570          	else if (test_type == 3)
   3571          	{
   3572          		if(check_link_state(g_param.transfer_mode) == 0)
   3573          		{
   3574          			gui_TextOut_ext(CENTER_ALIGN,13,"确认是否已连接主机?",0,1);
   3575          		}
   3576          		else
   3577          		{
   3578          			gui_TextOut(0,0,"条码(S):",0,1);
   3579          			gui_TextOut(0,26,"扫描次数:",0,1);
   3580          			gui_TextOut(0,39,"传输次数:",0,1);
   3581          		}
   3582          		success_cnt = fail_cnt = 0;
   3583          	}
   3584          
   3585          	while (1)
   3586          	{
   3587          		if (test_type == 1)
   3588          		{
   3589          			memset(BarCode,0,31);
   3590          			memset(BarCode_Type,0,20);
   3591          			BarCode_Len = 0;
   3592          			if (UE988_get_barcode(BarCode_Type, BarCode,30, &BarCode_Len) == 0)
   3593          			{
   3594          				//获取到条码
   3595          				//led_r_ctrl(1);
   3596          				Delay(5000);
   3597          				//Beep(BEEP_DELAY);
   3598          				//led_r_ctrl(0);
   3599          
   3600          				gui_TextOut(48, 0,  "                                ", 0,0);
   3601          				if (strlen(BarCode) > 20)
   3602          				{
   3603          					gui_TextOut(48, 0,  BarCode, 0,0);
   3604          				}
   3605          				else
   3606          				{
   3607          					gui_TextOut_ext(CENTER_ALIGN, 13,  BarCode, 0,0);
   3608          				}
   3609          
   3610          				if ((success_cnt == 0) && (fail_cnt == 0))
   3611          				{
   3612          					strcpy(code_value,BarCode);
   3613          					success_cnt++;
   3614          				}
   3615          				else
   3616          				{
   3617          					if (strcmp(code_value,BarCode))
   3618          					{
   3619          						fail_cnt++;
   3620          					}
   3621          					else
   3622          					{
   3623          						success_cnt++;
   3624          					}
   3625          				}
   3626          
   3627          				sprintf((char*)str,"%d",success_cnt);
   3628          				gui_TextOut(9*6, 26,str, 0,0);
   3629          				sprintf((char*)str,"%d",fail_cnt);
   3630          				gui_TextOut(9*6, 39,str,0,0);
   3631          			}
   3632          		}
   3633          		else if (test_type == 2)
   3634          		{
   3635          			if (YFBT07_Connect_state())
   3636          			{	
   3637          				//连接状态
   3638          				bluetooth_match_cmd_cnt = 0;
   3639          				gui_TextOut(0,0,"连接成功!",0,1);
   3640          				if (i == 1)
   3641          				{
   3642          					gui_TextOut(0,13,"按[scan]进行数据传输",0,1);
   3643          					while(1)
   3644          					{
   3645          						key = keypad_getkey();
   3646          						if((key) && (KEY_SCAN == *key)) 
   3647          						{
   3648          							Beep(BEEP_DELAY);
   3649          							break;
   3650          						}
   3651          					}
   3652          				}
   3653          
   3654          				gui_TextOut(0,13,"正在进行数据传输...",0,1);
   3655          				i = 2;
   3656          				memset(code_value,0,31);
   3657          				for (i = 0; i < success_cnt;i++)
   3658          				{
   3659          					if (fail_cnt > 0x7e)
   3660          					{
   3661          						fail_cnt = 0x20;
   3662          					}
   3663          					code_value[i] = fail_cnt++;
   3664          				}
   3665          				success_cnt++;
   3666          				if (success_cnt > 30)
   3667          				{
   3668          					success_cnt = 2;
   3669          				}
   3670          
   3671          				
   3672          				YFBT07_SendKey(code_value,strlen(code_value));
   3673          				YFBT07_SendKey("\x0d",1);
   3674          
   3675          				gui_TextOut(0,26+(success_cnt%3)*13,"                    ",0,0);
   3676          				gui_TextOut(0,26+(success_cnt%3)*13,code_value,0,0);
   3677          
   3678          			}
   3679          			else 
   3680          			{
   3681          				//如果是处于未连接状态，那么就间隔2分钟发送一次匹配命令
   3682          				if(i == 2)
   3683          				{
   3684          					gui_TextOut(0,0,"连接断开!",0,0);
   3685          					gui_TextOut(0,13,"数据传输被中断!     ",0,0);
   3686          				}
   3687          				
   3688          				if (bluetooth_module_state == 0)
   3689          				{
   3690          					bluetooth_state_cnt = 0;
   3691          					if (bluetooth_match_cmd_cnt == 600)
   3692          					{
   3693          						bluetooth_match_cmd_cnt = 0;
   3694          						YFBT07_Enter_Match_Mode();
   3695          					}
   3696          					if (bluetooth_match_cmd_cnt%80 == 0)
   3697          					{
   3698          						YFBT07_SendKey("\x0d",1);
   3699          					}
   3700          					bluetooth_match_cmd_cnt ++;
   3701          				}
   3702          				else
   3703          				{
   3704          					if(bluetooth_state_cnt == 200)
   3705          					{
   3706          						bluetooth_state_cnt = 0;
   3707          						bluetooth_module_state = YFBT07_check();
   3708          					}
   3709          					bluetooth_state_cnt++;
   3710          				}
   3711          			}
   3712          		}
   3713          		else if (test_type == 3)
   3714          		{
   3715          			if(check_link_state(g_param.transfer_mode) == 0)
   3716          			{
   3717          				gui_FillRect(0,0,LCD_WIDTH,13*4,0,0);
   3718          				gui_TextOut_ext(CENTER_ALIGN,26,"连接中断!",0,0);
   3719          			}
   3720          			else
   3721          			{
   3722          				memset(BarCode,0,31);
   3723          				memset(BarCode_Type,0,20);
   3724          				BarCode_Len = 0;
   3725          				if (UE988_get_barcode(BarCode_Type, BarCode,30, &BarCode_Len) == 0)
   3726          				{
   3727          					//获取到条码
   3728          					//led_r_ctrl(1);
   3729          					Delay(5000);
   3730          					//Beep(BEEP_DELAY);
   3731          					//led_r_ctrl(0);
   3732          
   3733          					gui_TextOut(48, 0,  "                                ", 0,0);
   3734          					if (strlen(BarCode) > 20)
   3735          					{
   3736          						gui_TextOut(48, 0,  BarCode, 0,0);
   3737          					}
   3738          					else
   3739          					{
   3740          						gui_TextOut_ext(CENTER_ALIGN, 13,  BarCode, 0,0);
   3741          					}
   3742          
   3743          					success_cnt++;
   3744          					transfer_barcode_str(BarCode,g_param.transfer_mode);
   3745          					transfer_barcode_str("\x0d",g_param.transfer_mode);
   3746          					fail_cnt++;
   3747          
   3748          					sprintf((char*)str,"%d",success_cnt);
   3749          					gui_TextOut(9*6, 26,str, 0,0);
   3750          					sprintf((char*)str,"%d",fail_cnt);
   3751          					gui_TextOut(9*6, 39,str,0,0);
   3752          
   3753          				}
   3754          			}
   3755          		}
   3756          
   3757          		gui_refresh(0,0,LCD_WIDTH,LCD_HEIGHT);
   3758          
   3759          		key = keypad_getkey();
   3760          		if((key) && (KEY_ESC == *key)) 
   3761          		{
   3762          			Beep(BEEP_DELAY);
   3763          			break;
   3764          		}
   3765          
   3766          		//Delay(400000);	//约200ms
   3767          		OSTimeDlyHMSM(0,0,0,200);
   3768          	}
   3769          
   3770          	if (test_type == 2)
   3771          	{
   3772          		g_param.transfer_mode = transfer_mode_save;
   3773          		device_init_by_setting();
   3774          	}
   3775          	//OSSchedUnlock();
   3776          }
   3777          
   3778          /**
   3779          * @brief 测试菜单界面
   3780          */
   3781          static unsigned char dlgproc_test_menu(unsigned char type,unsigned char *key)
   3782          {
   3783          	return proc_list_menu(type,key);
   3784          }
   3785          
   3786          
   3787          /**
   3788          * @brief 老化测试界面
   3789          */
   3790          static unsigned char dlgproc_age_test_menu(unsigned char type,unsigned char *key)
   3791          {
   3792          	unsigned char test_type;
   3793          
   3794          	if (DLGCB_RUN == type)
   3795          	{
   3796          		if (KEY_SCAN == *key || KEY_ENTER == *key)
   3797          		{
   3798          			//menu_current_item = 1 进入扫描头老化测试任务
   3799          			//menu_current_item = 2 进入蓝牙传输老化测试任务
   3800          			//menu_current_item = 3 进入扫描+传输老化测试任务
   3801          			test_type = menu_current_item;
   3802          			enter_test_task(test_type);
   3803          			*key = KEY_EXT_1;
   3804          			return RUN_NEXT;
   3805          		}
   3806          
   3807          		if (KEY_LEFT_SHOTCUT == *key)
   3808          		{
   3809          			*key = KEY_ESC;
   3810          			return RUN_NEXT;
   3811          		}
   3812          
   3813          	}
   3814          	return RUN_CONTINUE;
   3815          }
   3816          
   3817          /**
   3818          * @brief 单项测试菜单界面
   3819          */
   3820          static unsigned char dlgproc_single_test_menu(unsigned char type,unsigned char *key)
   3821          {
   3822          	return proc_list_menu(type,key);
   3823          }
   3824          
   3825          
   3826          /*
   3827          *
   3828          *
   3829          */
   3830          int  GetPowerVoltage_test_mode(void)
   3831          {
   3832          	unsigned int  i,result = 0;
   3833          	unsigned short  temp[20];
   3834          	unsigned short	min,max;
   3835          
   3836          	for(i = 0;i < 20;i++)
   3837          	{
   3838          		temp[i] = ADC_GetConversionValue(ADC1);		//得到AD转换的结果
   3839          		result += temp[i];
   3840          		if (i == 0)
   3841          		{
   3842          			min = temp[i];
   3843          			max = temp[i];
   3844          		}
   3845          
   3846          		if (temp[i] < min)
   3847          		{
   3848          			min = temp[i];
   3849          		}
   3850          
   3851          		if (temp[i] > max)
   3852          		{
   3853          			max = temp[i];
   3854          		}
   3855          	}
   3856          
   3857          	//取20次值之后,去掉最小值和最大周，再取平均值，简单的平滑滤波
   3858          	result -= min;
   3859          	result -= max;
   3860          	result /= 18; 
   3861          
   3862          	return result;
   3863          
   3864          }
   3865          
   3866          /*
   3867          *@brief  LCD 背光及LED测试控制测试
   3868          */
   3869          void test_check_key(void)
   3870          {
   3871          	unsigned char *key = NULL;
   3872          	volatile unsigned int  delay_cnt;    
   3873          	key = keypad_getkey();
   3874          	for(delay_cnt = 0;delay_cnt < 20000*190;delay_cnt++);
   3875          	while (1) 
   3876          	{
   3877          		for(delay_cnt = 0;delay_cnt < 20000*10;delay_cnt++);
   3878          		//OSTimeDlyHMSM(0,0,0,200);
   3879          		key = keypad_getkey();
   3880          		if ((key) && ((KEY_ENTER == (*key))||(KEY_RIGHT_SHOTCUT == (*key))||(KEY_SCAN == (*key)))) 
   3881          		{
   3882          			Beep(BEEP_DELAY);
   3883          			break;
   3884          		}
   3885          	}
   3886          }
   3887          
   3888          /*
   3889          *@brief  LCD 背光及LED测试控制测试
   3890          */
   3891          static void test_LCD_display(void)
   3892          {
   3893          	OSSchedLock();
   3894          	Lcd_Clear(0xffff);
   3895          	//test_check_key();
   3896          	//Lcd_Clear(0);
   3897          	//test_check_key();
   3898          	//displaycom();
   3899          	//test_check_key();
   3900          	//displaycom1();
   3901          	//test_check_key();
   3902          	//displayseg();
   3903          	//test_check_key();
   3904          	//displayseg1();
   3905          	test_check_key();
   3906          	displaysnow();
   3907          	test_check_key();
   3908          	Lcd_Clear(0);
   3909          	OSSchedUnlock();
   3910          }
   3911          
   3912          /**
   3913          * @brief  蜂鸣器测试
   3914          */
   3915          #if 0
   3916          static void testbuzzer(void)
   3917          {
   3918          	Beep(6*BEEP_DELAY);
   3919          	OSTimeDlyHMSM(0,0,1,0);
   3920          	Beep(BEEP_DELAY);
   3921          	OSTimeDlyHMSM(0,0,1,0);
   3922          	Beep(BEEP_DELAY);
   3923          	OSTimeDlyHMSM(0,0,1,0);
   3924          }
   3925          #endif
   3926          
   3927          
   3928          
   3929          /*
   3930          *@brief: 按键测试
   3931          */
   3932          static void testKeypad(void)
   3933          {
   3934          	unsigned char * key;
   3935          	unsigned char lastkey = 0xff;
   3936          	int i = 0;
   3937          	int keyscancnt = 0;
   3938          
   3939          	for (keyscancnt = 0;keyscancnt < KEY_COUNT;keyscancnt++)
   3940          	{
   3941          		keyscan_pos_width_tbl[keyscancnt].clear_flag = 1;		//清掉标记
   3942          	}
   3943          
   3944          	keyscancnt = 0;
   3945          
   3946          	gui_FillRect(0, 0, GUI_WIDTH, GUI_HEIGHT-SHOTCUT_HEIGNT-6, BG_COLOR,0);
   3947          	//gui_FillRect(0, ICON_HEIGHT+1, 240, 250, BG_COLOR);
   3948          	 
   3949          	gui_TextOut(0, 0,      "POWER", 0,0);
   3950          	gui_TextOut(0, 13,   "[-] ESC ENTER [-]", 0,0);
   3951          	gui_TextOut(0, 26, "LEFT UP RIGHT DOWN", 0,0);
   3952          	gui_TextOut(0, 39, "      SCAN", 0,0);
   3953          	gui_refresh(0,0,GUI_WIDTH,GUI_HEIGHT);
   3954          
   3955          	OSTimeDlyHMSM(0,0,1,0);
   3956          	OSSchedLock();		//不要再进行任务调度了，防止键值触发其它任务
   3957          	while (1) 
   3958          	{
   3959          		key = keypad_getkey();
   3960          
   3961          		if ((key)&&(lastkey != (*key))) 
   3962          		{
   3963          			lastkey = *key;
   3964          			Beep(BEEP_DELAY);
   3965          			i = 0;
   3966          			while (keyscan_pos_width_tbl[i].key != 0xff)	//搜索表格
   3967          			{
   3968          				if ((*key == keyscan_pos_width_tbl[i].key)&&(keyscan_pos_width_tbl[i].clear_flag == 1))
   3969          				{
   3970          					keyscan_pos_width_tbl[i].clear_flag = 0;		//清掉标记
   3971          					gui_FillRect(keyscan_pos_width_tbl[i].x,keyscan_pos_width_tbl[i].y, 6*keyscan_pos_width_tbl[i].width, 13, BG_COLOR,1);
   3972          					keyscancnt ++;		//记住已经扫描了多少个键
   3973          					break;
   3974          				}
   3975          				i++;
   3976          			}
   3977          		}
   3978          		if (keyscancnt == KEY_COUNT)		//按键扫描完了退出//
   3979          		{
   3980          			break;
   3981          		}
   3982          	}
   3983          	OSSchedUnlock();		//任务解锁
   3984          	return;
   3985          }
   3986          
   3987          
   3988          //扫描头测试
   3989          static void testScanerInit(void)
   3990          {
   3991          	unsigned char dis_str[5];
   3992          	//unsigned char tmp[31];
   3993          	int           ret = 0;
   3994          	int			  command;
   3995          	unsigned char scan_success_flag = 0;
   3996          
   3997          	gui_FillRect(0, 0, GUI_WIDTH, GUI_HEIGHT-SHOTCUT_HEIGNT-6, BG_COLOR,0);
   3998          	gui_TextOut(0,0,"条码(S):",0,0);
   3999          	//gui_LineH(0,13,20*6,TXT_COLOR,0);
   4000          	gui_TextOut(0,26,"条码类型:",0,0);
   4001          	//gui_LineH(0,39,20*6,TXT_COLOR,0);
   4002          	gui_refresh(0,0,GUI_WIDTH,GUI_HEIGHT);
   4003          
   4004          	scan_success_flag = 0;
   4005          	while(1)
   4006          	{
   4007          		ret = task_read_command_from_ui(&command, 0); 
   4008          		if( !ret &&(TASK_CONTINUE == command))
   4009          		{
   4010          			//用户按了扫描键
   4011          			//开始扫描商品条形码
   4012          			//scan_start = 1;
   4013          			memset(BarCode,0,31);
   4014          			//memset(tmp,0,31);
   4015          			memset(BarCode_Type,0,20);
   4016          			BarCode_Len = 0;
   4017          			if (UE988_get_barcode(BarCode_Type, BarCode,20, &BarCode_Len) == 0)
   4018          				//if (scanner_get_barcode(BarCode,30,BarCode_Type,&BarCode_Len)  == 0)
   4019          			{
   4020          				//获取到条码
   4021          				Delay(5000);
   4022          				Beep(BEEP_DELAY);
   4023          				barcode_got_flag = 1;
   4024          				scan_start = 0;
   4025          
   4026          				//显示条码
   4027          				//gui_TextOut()
   4028          				//后台扫描条形码结束 
   4029          				//那么需要将后台获取到的条形码显示出来
   4030          
   4031          				if ((BarCode[0] != 0)&&(BarCode_Len != 0))
   4032          				{
   4033          					gui_TextOut_ext(CENTER_ALIGN,13,BarCode,0,1);
   4034          					gui_TextOut_ext(CENTER_ALIGN,39,BarCode_Type,0,1);
   4035          					//hex_to_str(((BarCode_Len > 30)?30:BarCode_Len),10,0,dis_str);
   4036          					//gui_TextOut_ext(CENTER_ALIGN,LINE6,dis_str,1);
   4037          				}
   4038          				//gui_SetTextColor(TXT_COLOR);
   4039          
   4040          				enter_scaner_test_flag  = 2;	//进入扫描测试的标志清零，退出扫描测试
   4041          				scan_success_flag		= 1;	//用来表示已经测试成功
   4042          
   4043          				//gui_TextOut(4,240,"Press [OK] key to begin next ",0);
   4044          				//gui_TextOut(4,240+18,"test!",0);
   4045          				//gui_TextOut(4,240+18+20,"Press [A] key to continue ",0);
   4046          				//gui_TextOut(4,240+18+20+18,"scanning!",0);
   4047          				//gui_SetTextColor(TXT_COLOR);
   4048          
   4049          			}
   4050          			scan_start = 0;
   4051          		}
   4052          		else if( !ret && (TASK_RUN == command) && scan_success_flag)
   4053          		{
   4054          			break;
   4055          		}
   4056          
   4057          	}
   4058          
   4059          }
   4060          
   4061          
   4062          //蓝牙模块测试
   4063          static void testBluetooth(void)
   4064          {
   4065          	OSSchedLock();		//不要再进行任务调度了，防止键值触发其它任务
   4066          	YFBT07_Test();
   4067          	OSSchedUnlock();		//任务解锁
   4068          
   4069          }
   4070          
   4071          
   4072          //USB测试
   4073          static void testUSB(void)//USB测试
   4074          {
   4075          	unsigned char i = 0;
   4076          
   4077          #if 1
   4078          
   4079          	usb_device_init(USB_KEYBOARD);	//将设备初始化为一个
   4080          	USB_Cable_Config(1);
   4081          	
   4082          	OSSchedLock();		//不要再进行任务调度了，防止键值触发其它任务
   4083          	gui_FillRect(0, 0, GUI_WIDTH, GUI_HEIGHT-SHOTCUT_HEIGNT-6, BG_COLOR,0);
   4084          	gui_TextOut_ext(CENTER_ALIGN,13,"连接USB线!",0,0);
   4085          	gui_TextOut(40,26,"等待中",0,0);
   4086          	gui_refresh(0,0,GUI_WIDTH,GUI_HEIGHT);
   4087          
   4088          	while (CONFIGURED != bDeviceState)
   4089          	{
   4090          		switch ( i = (i+1)%5)
   4091          		{
   4092          		case 0:
   4093          			gui_TextOut(40+12*3,26,"...",0,1);
   4094          			break;
   4095          		case 2:
   4096          			gui_TextOut(40+12*3,26,".  ",0,1);
   4097          			break;
   4098          		case 3:
   4099          			gui_TextOut(40+12*3,26,"   ",0,1);
   4100          			break;
   4101          		case 1:
   4102          		case 4:
   4103          			gui_TextOut(40+12*3,26,".. ",0,1);
   4104          		}
   4105          		//OSTimeDlyHMSM(0,0,0,500);//暂停0.5 s
   4106          		Delay(9000000);
   4107          	}
   4108          
   4109          	gui_TextOut(0,26,"                   ",0,1);//擦除“Waiting”
   4110          	gui_TextOut_ext(CENTER_ALIGN,26,"USB连接成功!",0,1);//usb连接成功！
   4111          	Beep(BEEP_DELAY);
   4112          	OSSchedUnlock();		//不要再进任务调度了，防止键值触发其它任务
   4113          	OSTimeDlyHMSM(0,0,1,500);//暂停1.5 s
   4114          
   4115          #endif
   4116          
   4117          }
   4118          
   4119          
   4120          //RTC测试
   4121          static void testRTC(void)//rtc测试
   4122          {
   4123          	volatile int  n;
   4124          	unsigned char sec_save;
   4125          
   4126          	gui_FillRect(0, 0, GUI_WIDTH, GUI_HEIGHT-SHOTCUT_HEIGNT-6, BG_COLOR,1);
   4127          INIT_RTC:
   4128          
   4129          	SD2068A_GetTime((unsigned char*)&currentDateTime);
   4130          	sec_save = currentDateTime.sec;
   4131          	OSTimeDlyHMSM(0,0,1,50);//延时1.05s
   4132          	SD2068A_GetTime((unsigned char*)&currentDateTime);
   4133          	if ((currentDateTime.sec+60-sec_save)%60 >= 1 )
   4134          	{
   4135          		gui_TextOut_ext(CENTER_ALIGN,26,"RTC 工作正常",0,1);
   4136          		//设置CC1101模块与基站匹配的频段
   4137          		OSTimeDlyHMSM(0,0,1,500);//暂停1.5 s
   4138          	}
   4139          	else
   4140          	{
   4141          		gui_TextOut_ext(CENTER_ALIGN,26,"RTC 工作错误",0,1);
   4142          		//设置CC1101模块与基站匹配的频段
   4143          		OSTimeDlyHMSM(0,0,1,500);//暂停1.5 s
   4144          		goto  INIT_RTC;//
   4145          	}
   4146          
   4147          }
   4148          
   4149          //RTC测试
   4150          static void testAD(void)//rtc测试
   4151          {
   4152          	int i,vol_value,val_value_aver,vol_value_final;
   4153          
   4154          	gui_FillRect(0, 0, GUI_WIDTH, GUI_HEIGHT-SHOTCUT_HEIGNT-6, BG_COLOR,1);
   4155          
   4156          	val_value_aver = 0;
   4157          	for (i = 0;i < 10;i++)
   4158          	{
   4159          		vol_value = GetPowerVoltage_test_mode();
   4160          		val_value_aver += vol_value; 
   4161          		OSTimeDlyHMSM(0,0,0,50);
   4162          	}
   4163          
   4164          	val_value_aver = val_value_aver/10;
   4165          	vol_value_final = (val_value_aver*7705)/10000;
   4166          
   4167          	if ((vol_value_final >= 2300)&&(vol_value_final <=2500))
   4168          	{
   4169          		gui_TextOut_ext(CENTER_ALIGN,26,"AD采样正常",0,1);
   4170          		OSTimeDlyHMSM(0,0,1,500);//暂停1.5 s
   4171          	}
   4172          	else
   4173          	{
   4174          		gui_TextOut_ext(CENTER_ALIGN,26,"AD采样错误",0,1);
   4175          		Beep(BEEP_DELAY*2);
   4176          		OSTimeDlyHMSM(0,0,1,300);//暂停1.5 s
   4177          	}
   4178          }
   4179          
   4180          
   4181          /**
   4182          * @brief 工厂测试的后台任务
   4183          * @param[in] none                                 
   4184          */
   4185          static int factory_test_task(int param1, int param2, void *param3, void *param4)
   4186          {	
   4187          	int								command;
   4188          	//测试项目标号，根据其查询testfunc_tbl这个表来获取相应的测试函数
   4189          	int								testItemNum = 0;
   4190          	//int max = sizeof(testfunc_tbl);
   4191          	while(1)
   4192          	{
   4193          		while(1)
   4194          		{
   4195          			// 等待UI指令
   4196          			if( task_read_command_from_ui(&command, 0) == 0)
   4197          			{
   4198          				if(command == TASK_RUN)
   4199          				{
   4200          					break;			// 测试开始
   4201          				}
   4202          
   4203          				if(command == TASK_EXIT)
   4204          				{
   4205          					return KEY_EXT_2;			// 用户取消
   4206          				}
   4207          			}
   4208          		}
   4209          
   4210          		testfunc_tbl[testItemNum]();				//调用相应的测试函数完成该项的测试
   4211          		task_send_command_to_ui(KEY_EXT_1);			//某项测试完成	
   4212          		testItemNum ++;								//测试项目标号加1，进行下一项的测试
   4213          
   4214          		if (testItemNum == sizeof(testfunc_tbl)/sizeof(int))			//测试全部完成，退出此后台任务
   4215          		{
   4216          			break;
   4217          		}
   4218          	}
   4219          	return KEY_EXT_1;		//测试完成
   4220          }
   4221          
   4222          
   4223          
   4224          /**
   4225          * @brief 生产测试的窗体回调调用的公共回调函数
   4226          */
   4227          static unsigned char dlgproc_test_proc(unsigned char *key)
   4228          {
   4229          	if (*key == KEY_ENTER || *key == KEY_SCAN || *key == KEY_RIGHT_SHOTCUT)
   4230          	{
   4231          		if (testproc_first_enterkey == 1) 
   4232          		{
   4233          			testproc_first_enterkey = 0;			//清掉这个标记
   4234          			ui_send_command_to_task(TASK_RUN);
   4235          			return RUN_RERUN;
   4236          		}
   4237          		else 
   4238          		{
   4239          			if (1 == enter_scaner_test_flag)
   4240          			{
   4241          				ui_send_command_to_task(TASK_CONTINUE);
   4242          				return RUN_RERUN;
   4243          			}
   4244          			else if(2 == enter_scaner_test_flag)
   4245          			{
   4246          				ui_send_command_to_task(TASK_RUN);		//用意使扫描测试退出
   4247          				return RUN_RERUN;
   4248          			}
   4249          			else
   4250          			{
   4251          				return RUN_RERUN;
   4252          			}
   4253          		}
   4254          
   4255          	}
   4256          
   4257          	if (*key == KEY_EXT_1)		//后台运行完一项测试，就会返回这个键值
   4258          	{
   4259          		*key = KEY_ENTER;
   4260          		return RUN_NEXT;
   4261          	}
   4262          
   4263          	if (*key == KEY_ESC) 
   4264          	{
   4265          		return RUN_RERUN;
   4266          	}
   4267          
   4268          	/*
   4269          	if (*key == KEY_ESC) 
   4270          	{
   4271          	pos_state &= ~STA_FACTORY_MODE;		//清掉测试模式的状态机
   4272          	ui_send_command_to_task(TASK_EXIT);
   4273          	return RUN_RERUN;
   4274          	}
   4275          
   4276          	if (*key == KEY_EXT_2)		//后台任务被取消
   4277          	{
   4278          	*key = KEY_ESC;
   4279          	return RUN_NEXT;
   4280          	}
   4281          	*/ 
   4282          
   4283          	return RUN_CONTINUE;
   4284          }
   4285          
   4286          /*
   4287          *显示测试界面
   4288          */
   4289          unsigned char dlgproc_test_lcd_display(unsigned char type,unsigned char *key)
   4290          {
   4291          	if( type == DLGCB_DRAW )
   4292          	{
   4293          		testproc_first_enterkey = 1;	//绘制窗体时给置位这个标记
   4294          		enter_scaner_test_flag  = 0;//进入扫描测试的标志初始化
   4295          		//开始在后台运行生产测试程序
   4296          		dlg_run_bgtask(factory_test_task, 0, 0, 0, 0);
   4297          	}
   4298          
   4299          	if (type == DLGCB_RUN) 
   4300          	{
   4301          		return dlgproc_test_proc(key);
   4302          	}
   4303          
   4304          	return RUN_CONTINUE;
   4305          }
   4306          
   4307          
   4308          
   4309          /*
   4310          *测试按键
   4311          */
   4312          unsigned char dlgproc_test_keypad(unsigned char type,unsigned char *key)
   4313          {
   4314          	if( type == DLGCB_DRAW )
   4315          	{
   4316          		testproc_first_enterkey = 1;	//绘制窗体时给置位这个标记
   4317          	}
   4318          	if (type == DLGCB_RUN) 
   4319          	{
   4320          		return dlgproc_test_proc(key);
   4321          	}
   4322          	return RUN_CONTINUE;
   4323          }
   4324          
   4325          
   4326          
   4327          /*
   4328          *测试扫描头
   4329          */
   4330          unsigned char dlgproc_test_scaner_init(unsigned char type,unsigned char *key)
   4331          {
   4332          	if( DLGCB_DRAW == type)
   4333          	{
   4334          		scan_start				= 0;    //可以开始扫描
   4335          		enter_scaner_test_flag  = 1;	//进入扫描测试的标志
   4336          		testproc_first_enterkey = 1;	//绘制窗体时给置位这个标记
   4337          	}
   4338          
   4339          	if (DLGCB_RUN  == type)
   4340          	{
   4341          		return dlgproc_test_proc(key);
   4342          	}
   4343          
   4344          	if (DLGCB_DESTORY == type)
   4345          	{
   4346          		enter_scaner_test_flag  = 0;			//清掉这个标记
   4347          	}
   4348          
   4349          	return RUN_CONTINUE;
   4350          
   4351          }
   4352          
   4353          /*
   4354          *测试cc1101
   4355          */
   4356          unsigned char dlgproc_test_bluetooth(unsigned char type,unsigned char *key)
   4357          {
   4358          	if( type == DLGCB_DRAW )
   4359          	{
   4360          		testproc_first_enterkey = 1;	//绘制窗体时给置位这个标记
   4361          	}
   4362          
   4363          	if (type == DLGCB_RUN) 
   4364          	{
   4365          		return dlgproc_test_proc(key);
   4366          	}
   4367          	return RUN_CONTINUE;
   4368          
   4369          }
   4370          
   4371          /*
   4372          *测试usb
   4373          */
   4374          unsigned char dlgproc_test_usb(unsigned char type,unsigned char *key)
   4375          {
   4376          	if( type == DLGCB_DRAW )
   4377          	{
   4378          		testproc_first_enterkey = 1;	//绘制窗体时给置位这个标记
   4379          	}
   4380          
   4381          	if (type == DLGCB_RUN) 
   4382          	{
   4383          		return dlgproc_test_proc(key);
   4384          	}
   4385          	return RUN_CONTINUE;
   4386          
   4387          }
   4388          
   4389          /*
   4390          *测试rtc
   4391          */
   4392          unsigned char dlgproc_test_rtc(unsigned char type,unsigned char *key)
   4393          {
   4394          	if( type == DLGCB_DRAW )
   4395          	{
   4396          		testproc_first_enterkey = 1;	//绘制窗体时给置位这个标记
   4397          	}
   4398          
   4399          	if (type == DLGCB_RUN) 
   4400          	{
   4401          		return dlgproc_test_proc(key);
   4402          	}
   4403          	return RUN_CONTINUE;
   4404          
   4405          }
   4406          
   4407          /*
   4408          *测试rtc
   4409          */
   4410          unsigned char dlgproc_test_AD(unsigned char type,unsigned char *key)
   4411          {
   4412          	if( type == DLGCB_DRAW )
   4413          	{
   4414          		testproc_first_enterkey = 1;	//绘制窗体时给置位这个标记
   4415          	}
   4416          
   4417          	if (type == DLGCB_RUN) 
   4418          	{
   4419          		return dlgproc_test_proc(key);
   4420          	}
   4421          	return RUN_CONTINUE;
   4422          
   4423          }
   4424          
   4425          /*
   4426          *
   4427          */
   4428          unsigned char dlgproc_test_complete(unsigned char type,unsigned char *key)
   4429          {
   4430          
   4431          	if( type == DLGCB_DRAW )
   4432          	{
   4433          		testproc_first_enterkey = 1;	//绘制窗体时给置位这个标记
   4434          
   4435          		// pos_run_mode = ;
   4436          		//OSTimeDlyHMSM(0,0,1,0);
   4437          		//gui_CtrlBL(0);
   4438          		/* Request to enter STOP mode with regulator ON */
   4439          		//PWR_EnterSTOPMode(PWR_Regulator_ON, PWR_STOPEntry_WFI);
   4440          		//PWR_EnterSTOPMode(PWR_Regulator_LowPower, PWR_STOPEntry_WFI);
   4441          
   4442          		RCC_Configuration();
   4443          		/* Allow access to BKP Domain */
   4444          		//PWR_BackupAccessCmd(ENABLE);
   4445          		Calendar_Init();
   4446          
   4447          		USB_Cable_Config(0);
   4448          		OSTimeDlyHMSM(0,0,0,300);
   4449          		USB_Cable_Config(1);
   4450          
   4451          	}
   4452          	return RUN_CONTINUE;
   4453          }

   Maximum stack usage in bytes:

     Function                       .cstack
     --------                       -------
     GetPowerVoltage_test_mode          64
     ScanBarCode_task                   48
     app_init                            8
     batch_data_send_proc               16
     batch_save_barcode_str             88
     build_transfer_str                 40
     check_link_state                    8
     check_time                         16
     data_trans_proc_callback           16
     data_trans_task                    32
     device_init_by_setting              8
     display_copyright_info             88
     display_goods_spec                 24
     display_hh_result                  16
     dlgproc_about_copyright            16
     dlgproc_add_date_option             8
     dlgproc_add_time_option             8
     dlgproc_age_test_menu               8
     dlgproc_avoid_dunplication_option
                                         8
     dlgproc_barcode_option              8
     dlgproc_barcode_statistic_option
                                         8
     dlgproc_batch_data_clear           24
     dlgproc_batch_data_send            40
     dlgproc_batch_transfer_mode        16
     dlgproc_beeper_vol_option           8
     dlgproc_bluetooth_info             16
     dlgproc_clear_file_ack             24
     dlgproc_clear_scan_record          24
     dlgproc_create_new_file            32
     dlgproc_data_transfer_func         24
     dlgproc_database_query_option       8
     dlgproc_decoder_setting            16
     dlgproc_default_setting            24
     dlgproc_delete_file_ack            24
     dlgproc_file_list                  16
     dlgproc_file_options_menu           8
     dlgproc_firmware_info              40
     dlgproc_import_database            24
     dlgproc_input_barcode               8
     dlgproc_input_send_num             24
     dlgproc_invalid_offset_setting     24
     dlgproc_language_option             8
     dlgproc_logo                       16
     dlgproc_modify_num_ack             24
     dlgproc_quantity_enter_menu         8
     dlgproc_scan_func                  40
     dlgproc_scan_mode_menu             16
     dlgproc_scan_option_menu            8
     dlgproc_seperator_setting           8
     dlgproc_set_system_password         0
     dlgproc_single_test_menu            8
     dlgproc_system_info                 8
     dlgproc_terminal_setting            8
     dlgproc_test_AD                     8
     dlgproc_test_bluetooth              8
     dlgproc_test_complete               8
     dlgproc_test_keypad                 8
     dlgproc_test_lcd_display           24
     dlgproc_test_menu                   8
     dlgproc_test_proc                   8
     dlgproc_test_rtc                    8
     dlgproc_test_scaner_init            8
     dlgproc_test_usb                    8
     dlgproc_time_date_setting          32
     dlgproc_timeout_option              8
     dlgproc_transfer_batch_option       8
     dlgproc_transfer_bluetooth_option
                                         8
     dlgproc_transfer_confirm_option
                                         8
     dlgproc_transfer_u_disk_option      8
     dlgproc_u_disk_format              24
     dlgproc_view_memery                72
     enter_test_task                    80
     err_tip                            16
     factory_test_task                  16
     memcpy                              8
     memset                              8
     proc_list_menu                      8
     proc_option_select                 16
     refresh_current_select_item        24
     refresh_decoder_switch_map         24
     refresh_file_list                  24
     refresh_home_item                  16
     scan_files                         64
     strstr                              8
     task_ui                             8
     testAD                             24
     testBluetooth                       8
     testKeypad                         32
     testRTC                            16
     testScanerInit                     24
     testUSB                            16
     test_LCD_display                    8
     test_check_key                     16
     transfer_barcode_proc              72
     transfer_barcode_str              104


   Section sizes:

     Function/Label                                   Bytes
     --------------                                   -----
     memcpy                                             14
     memset                                             20
     strstr                                              8
     fengefu_str                                        12
     content_logo_1                                     12
     content_logo_2                                     12
     content_logo_3                                      4
     dlgres_logo                                        24
     jump_logo                                          16
     content_scan_func_1                                12
     content_scan_func_2                                12
     content_scan_func_3                                 4
     dlgres_scan_func                                   24
     jump_scan_func                                      8
     content_data_transfer_func_1                       40
     content_data_transfer_func_2                       40
     content_data_transfer_func_3                        4
     dlgres_data_transfer_func                          24
     jump_data_transfer_func                            16
     content_terminal_setting_1                         36
     content_terminal_setting_2                         36
     content_terminal_setting_3                          4
     dlgres_terminal_setting                            24
     jump_terminal_setting                              16
     content_system_info_1                              24
     content_system_info_2                              24
     content_system_info_3                               4
     dlgres_system_info                                 24
     jump_system_info                                   12
     content_about_copyright_1                           4
     content_about_copyright_2                           4
     content_about_copyright_3                           4
     dlgres_about_copyright                             24
     jump_about_copyright                                4
     content_scan_option_menu_1                         48
     content_scan_option_menu_2                         48
     content_scan_option_menu_3                          4
     dlgres_scan_option_menu                            24
     jump_scan_option_menu                              24
     content_scan_mode_menu_1                           24
     content_scan_mode_menu_2                           24
     content_scan_mode_menu_3                            4
     dlgres_scan_mode_menu                              24
     jump_scan_mode_menu                                 4
     content_quantity_enter_menu_1                      24
     content_quantity_enter_menu_2                      24
     content_quantity_enter_menu_3                       4
     dlgres_quantity_enter_menu                         24
     jump_quantity_enter_menu                            4
     content_add_time_option_1                          20
     content_add_time_option_2                          20
     content_add_time_option_3                           4
     dlgres_add_time_option                             24
     jump_add_time_option                                4
     content_add_date_option_1                          20
     content_add_date_option_2                          20
     content_add_date_option_3                           4
     dlgres_add_date_option                             24
     jump_add_date_option                                4
     content_input_barcode_1                             4
     content_input_barcode_2                             4
     content_input_barcode_3                             4
     editres_input_barcode                              16
     dlgres_input_barcode                               24
     jump_input_barcode                                  8
     content_input_send_num_1                            4
     content_input_send_num_2                            4
     content_input_send_num_3                            4
     editres_input_send_num                             16
     dlgres_input_send_num                              24
     jump_input_send_num                                 8
     content_seperator_setting_1                         4
     content_seperator_setting_2                         4
     content_seperator_setting_3                         4
     editres_seperator_setting                          16
     dlgres_seperator_setting                           24
     jump_seperator_setting                              4
     content_modify_num_ack_1                           12
     content_modify_num_ack_2                           12
     content_modify_num_ack_3                            4
     dlgres_modify_num_ack                              24
     jump_modify_num_ack                                 8
     content_database_query_option_1
                                                        20
     content_database_query_option_2
                                                        20
     content_database_query_option_3
                                                         4
     dlgres_database_query_option                       24
     jump_database_query_option                          4
     content_avoid_dunplication_option_1
                                                        20
     content_avoid_dunplication_option_2
                                                        20
     content_avoid_dunplication_option_3
                                                         4
     dlgres_avoid_dunplication_option
                                                        24
     jump_avoid_dunplication_option                      4
     content_barcode_statistic_option_1
                                                        20
     content_barcode_statistic_option_2
                                                        20
     content_barcode_statistic_option_3
                                                         4
     dlgres_barcode_statistic_option
                                                        24
     jump_barcode_statistic_option                       4
     content_transfer_confirm_option_1
                                                        20
     content_transfer_confirm_option_2
                                                        20
     content_transfer_confirm_option_3
                                                         4
     dlgres_transfer_confirm_option                     24
     jump_transfer_confirm_option                        4
     content_language_option_1                          20
     content_language_option_2                          20
     content_language_option_3                           4
     dlgres_language_option                             24
     jump_language_option                                4
     content_beeper_vol_option_1                        20
     content_beeper_vol_option_2                        20
     content_beeper_vol_option_3                         4
     dlgres_beeper_vol_option                           24
     jump_beeper_vol_option                              4
     content_timeout_option_1                           32
     content_timeout_option_2                           32
     content_timeout_option_3                            4
     dlgres_timeout_option                              24
     jump_timeout_option                                 4
     content_transfer_bluetooth_option_1
                                                        20
     content_transfer_bluetooth_option_2
                                                        20
     content_transfer_bluetooth_option_3
                                                         4
     dlgres_transfer_bluetooth_option
                                                        24
     jump_transfer_bluetooth_option                      4
     content_transfer_u_disk_option_1
                                                        24
     content_transfer_u_disk_option_2
                                                        24
     content_transfer_u_disk_option_3
                                                         4
     dlgres_transfer_u_disk_option                      24
     jump_transfer_u_disk_option                        12
     content_transfer_batch_option_1
                                                        24
     content_transfer_batch_option_2
                                                        24
     content_transfer_batch_option_3
                                                         4
     dlgres_transfer_batch_option                       24
     jump_transfer_batch_option                         12
     content_import_database_1                          12
     content_import_database_2                          12
     content_import_database_3                           4
     dlgres_import_database                             24
     jump_import_database                                4
     content_barcode_option_1                           20
     content_barcode_option_2                           20
     content_barcode_option_3                            4
     dlgres_barcode_option                              24
     jump_barcode_option                                 8
     content_time_date_setting_1                        24
     content_time_date_setting_2                        24
     content_time_date_setting_3                         4
     editres_time_date_setting                          16
     dlgres_time_date_setting                           24
     jump_time_date_setting                              4
     content_default_setting_1                          12
     content_default_setting_2                          12
     content_default_setting_3                           4
     dlgres_default_setting                             24
     jump_default_setting                                4
     content_set_system_password_1                      12
     content_set_system_password_2                      12
     content_set_system_password_3                       4
     dlgres_set_system_password                         24
     jump_set_system_password                            4
     content_decoder_setting_1                          60
     content_decoder_setting_2                          60
     content_decoder_setting_3                           4
     dlgres_decoder_setting                             24
     jump_decoder_setting                                4
     content_invalid_offset_setting_1
                                                        20
     content_invalid_offset_setting_2
                                                        20
     content_invalid_offset_setting_3
                                                         4
     editres_invalid_offset_setting1
                                                        16
     editres_invalid_offset_setting                     16
     dlgres_invalid_offset_setting                      24
     jump_invalid_offset_setting                         4
     content_batch_data_send_1                          12
     content_batch_data_send_2                          12
     content_batch_data_send_3                           4
     dlgres_batch_data_send                             24
     jump_batch_data_send                                8
     content_batch_transfer_mode_1                      24
     content_batch_transfer_mode_2                      24
     content_batch_transfer_mode_3                       4
     dlgres_batch_transfer_mode                         24
     jump_batch_transfer_mode                            4
     content_batch_data_clear_1                         12
     content_batch_data_clear_2                         12
     content_batch_data_clear_3                          4
     dlgres_batch_data_clear                            24
     jump_batch_data_clear                               8
     content_clear_scan_record_1                        12
     content_clear_scan_record_2                        12
     content_clear_scan_record_3                         4
     dlgres_clear_scan_record                           24
     jump_clear_scan_record                              8
     content_view_memery_1                              12
     content_view_memery_2                              12
     content_view_memery_3                               4
     dlgres_view_memery                                 24
     jump_view_memery                                    8
     content_bluetooth_info_1                           12
     content_bluetooth_info_2                           12
     content_bluetooth_info_3                            4
     dlgres_bluetooth_info                              24
     jump_bluetooth_info                                 8
     content_firmware_info_1                            12
     content_firmware_info_2                            12
     content_firmware_info_3                             4
     dlgres_firmware_info                               24
     jump_firmware_info                                  8
     content_create_new_file_1                          24
     content_create_new_file_2                          24
     content_create_new_file_3                           4
     editres_create_new_file                            16
     dlgres_create_new_file                             24
     jump_create_new_file                                8
     content_file_list_1                                12
     content_file_list_2                                12
     content_file_list_3                                 4
     dlgres_file_list                                   24
     jump_file_list                                      8
     content_u_disk_format_1                            12
     content_u_disk_format_2                            12
     content_u_disk_format_3                             4
     dlgres_u_disk_format                               24
     jump_u_disk_format                                  8
     content_file_options_menu_1                        20
     content_file_options_menu_2                        20
     content_file_options_menu_3                         4
     dlgres_file_options_menu                           24
     jump_file_options_menu                              8
     content_clear_file_ack_1                           12
     content_clear_file_ack_2                           12
     content_clear_file_ack_3                            4
     dlgres_clear_file_ack                              24
     jump_clear_file_ack                                 8
     content_delete_file_ack_1                          12
     content_delete_file_ack_2                          12
     content_delete_file_ack_3                           4
     dlgres_delete_file_ack                             24
     jump_delete_file_ack                                8
     content_test_menu_1                                 4
     content_test_menu_2                                20
     content_test_menu_3                                 4
     dlgres_test_menu                                   24
     jump_test_menu                                      8
     content_age_test_menu_1                             4
     content_age_test_menu_2                            24
     content_age_test_menu_3                             4
     dlgres_age_test_menu                               24
     jump_age_test_menu                                  8
     content_single_test_menu_1                          4
     content_single_test_menu_2                         40
     content_single_test_menu_3                          4
     dlgres_single_test_menu                            24
     jump_single_test_menu                               4
     content_test_lcd_display_1                          4
     content_test_lcd_display_2                         28
     content_test_lcd_display_3                          4
     dlgres_test_lcd_display                            24
     jump_test_lcd_display                               4
     content_test_keypad_1                               4
     content_test_keypad_2                              20
     content_test_keypad_3                               4
     dlgres_test_keypad                                 24
     jump_test_keypad                                    4
     content_test_scaner_init_1                          4
     content_test_scaner_init_2                         20
     content_test_scaner_init_3                          4
     dlgres_test_scaner_init                            24
     jump_test_scaner_init                               4
     content_test_usb_1                                  4
     content_test_usb_2                                 16
     content_test_usb_3                                  4
     dlgres_test_usb                                    24
     jump_test_usb                                       4
     content_test_rtc_1                                  4
     content_test_rtc_2                                  4
     content_test_rtc_3                                  4
     dlgres_test_rtc                                    24
     jump_test_rtc                                       4
     content_test_AD_1                                   4
     content_test_AD_2                                   4
     content_test_AD_3                                   4
     dlgres_test_AD                                     24
     jump_test_AD                                        4
     content_test_bluetooth_1                            4
     content_test_bluetooth_2                           20
     content_test_bluetooth_3                            4
     dlgres_test_bluetooth                              24
     jump_test_bluetooth                                 4
     content_test_complete_1                             4
     content_test_complete_2                             4
     content_test_complete_3                             4
     dlgres_test_complete                               24
     jump_test_complete                                  8
     content_todo_1                                     12
     content_todo_2                                     12
     content_todo_3                                      4
     dlgres_todo                                        24
     jump_todo                                           4
     dlg_actionlist                                   1140
     app_ver                                             4
     BarCode                                            32
     last_BarCode                                       32
     BarCode_Type                                       20
     BarCode_Len                                         1
     dlg_refresh_flag                                    1
     barcode_got_flag                                    4
     current_home_item                                   4
     scan_func_state                                     1
     valid_barcode_start_offset_tmp                      1
     valid_barcode_end_offset_tmp                        1
     line3_save                                         24
     tmp_op_timeout                                      1
     special_func_flag                                   1
     p_check_info                                        4
     p_goods_node                                        4
     searched_rec_index                                  4
     op_context                                        252
     send_num                                            4
     need_refresh_signal                                 1
     no_update_icon_flg                                  1
     task_exit_flag                                      1
     usb_cable_state                                     1
     need_refresh_edit_index_tbl                         4
     scan_start                                          4
     testfunc_tbl                                       28
     keyscan_pos_width_tbl                              88
     testproc_first_enterkey                             4
     enter_scaner_test_flag                              1
     ScanBarCode_task                                  324
     check_time                                        432
     refresh_home_item                                 340
     dlgproc_logo                                      360
     build_transfer_str                                176
     check_link_state                                  120
     batch_save_barcode_str                             92
     transfer_barcode_str                              280
     transfer_barcode_proc                             128
     err_tip                                           228
     display_goods_spec                                142
     dlgproc_scan_func                                2252
     proc_list_menu                                     64
     dlgproc_scan_option_menu                           10
     dlgproc_system_info                               296
     dlgproc_terminal_setting                           10
     refresh_current_select_item                        96
     dlgproc_data_transfer_func                        376
     batch_data_send_proc                               64
     dlgproc_batch_data_send                           276
     dlgproc_batch_transfer_mode                       108
     dlgproc_batch_data_clear                          272
     dlgproc_clear_scan_record                         272
     dlgproc_scan_mode_menu                             96
     proc_option_select                                232
     dlgproc_quantity_enter_menu                        16
     dlgproc_add_time_option                            16
     dlgproc_add_date_option                            16
     dlgproc_input_barcode                             324
     dlgproc_seperator_setting                         108
     dlgproc_input_send_num                            116
     dlgproc_modify_num_ack                            148
     dlgproc_database_query_option                      16
     dlgproc_avoid_dunplication_option
                                                        16
     dlgproc_barcode_statistic_option
                                                        16
     dlgproc_transfer_confirm_option
                                                        16
     dlgproc_language_option                            16
     dlgproc_beeper_vol_option                          16
     dlgproc_timeout_option                             16
     dlgproc_transfer_bluetooth_option
                                                        16
     dlgproc_transfer_u_disk_option                     10
     dlgproc_transfer_batch_option                      10
     display_hh_result                                 484
     data_trans_proc_callback                          112
     data_trans_task                                   324
     dlgproc_import_database                           372
     dlgproc_barcode_option                             10
     dlgproc_time_date_setting                         260
     dlgproc_default_setting                           132
     dlgproc_set_system_password                         4
     refresh_decoder_switch_map                        204
     dlgproc_decoder_setting                           148
     map_save                                            2
     dlgproc_invalid_offset_setting                    448
     dlgproc_view_memery                               140
     dlgproc_bluetooth_info                            116
     dlgproc_firmware_info                             204
     dlgproc_create_new_file                           616
     scan_files                                        140
     current_select_file                                16
     refresh_file_list                                 420
     start_display_offset                                1
     current_offset                                      1
     dlgproc_file_list                                 184
     pList                                               4
     file_cnt                                            1
     dlgproc_u_disk_format                             196
     dlgproc_file_options_menu                          10
     dlgproc_clear_file_ack                            236
     dlgproc_delete_file_ack                           304
     app_init                                          116
     task_ui                                            52
     device_init_by_setting                            252
     display_copyright_info                            428
     dlgproc_about_copyright                           100
     dlg_state                                           1
     enter_test_task                                  1344
     dlgproc_test_menu                                  10
     dlgproc_age_test_menu                              64
     dlgproc_single_test_menu                           10
     GetPowerVoltage_test_mode                         112
     test_check_key                                    100
     test_LCD_display                                   38
     testKeypad                                        308
     testScanerInit                                    284
     testBluetooth                                      16
     testUSB                                           320
     testRTC                                           156
     testAD                                            172
     factory_test_task                                  68
     dlgproc_test_proc                                 120
     dlgproc_test_lcd_display                           72
     dlgproc_test_keypad                                36
     dlgproc_test_scaner_init                           68
     dlgproc_test_bluetooth                             36
     dlgproc_test_usb                                   36
     dlgproc_test_rtc                                   36
     dlgproc_test_AD                                    36
     dlgproc_test_complete                              56
     ??DataTable7                                        4
     ??DataTable8                                        4
     ??DataTable27                                       4
     ??DataTable28                                       4
     ??DataTable34                                       4
     ??DataTable49                                       4
     ??DataTable68                                       4
     ??DataTable76                                       4
     ??DataTable77                                       4
     ??DataTable84                                       4
     ??DataTable91                                       4
     ??DataTable99                                       4
     ??DataTable101                                      4
     ??DataTable104                                      4
     ??DataTable105                                      4
     ?<Constant " ">                                     2
     ?<Constant "---------------------...">             36
     ?<Constant "Home">                                  8
     ?<Constant "Options">                               8
     ?<Constant "\321\241\317\356">                      8
     ?<Constant "  ">                                    4
     ?<Constant "Transfer Mode">                        16
     ?<Constant "         Select   Esc">                24
     ?<Constant "1 BlueTooth">                          12
     ?<Constant "2 USB Keyboard">                       16
     ?<Constant "3 USB Virtual COM">                    20
     ?<Constant "4 U Disk Mode">                        16
     ?<Constant "5 Batch Mode">                         16
     ?<Constant "6 Import Database">                    20
     ?<Constant "7 Seperator">                          12
     ?<Constant "\312\375\276\335\264\253\312\344 "     12
     ?<Constant "        \321\241\324\361     \315\     24
     ?<Constant "1 \300\266\321\300">                    8
     ?<Constant "2 USB\274\374\305\314">                12
     ?<Constant "3 USB\320\351\304\342\264\256\277\     16
     ?<Constant "4 U\305\314\304\243\312\275">          12
     ?<Constant "5 \315\321\273\372\264\346\264\242     12
     ?<Constant "6 \265\274\310\353\311\314\306\267     16
     ?<Constant "7 \267\326\270\364\267\373\311\350     16
     ?<Constant "Terminal Setting">                     20
     ?<Constant "       Select     Esc">                24
     ?<Constant "2 Language">                           12
     ?<Constant "3 Key Volume">                         16
     ?<Constant "4 Timeout Setting">                    20
     ?<Constant "5 DateTime">                           12
     ?<Constant "6 Default setting">                    20
     ?<Constant "\317\265\315\263\311\350\326\303 "     12
     ?<Constant "1 \314\365\302\353">                    8
     ?<Constant "2 \323\357\321\324">                    8
     ?<Constant "3 \260\264\274\374\322\364">           12
     ?<Constant "4 \263\254\312\261\311\350\326\303     12
     ?<Constant "5 \312\261\274\344\272\315\310\325     16
     ?<Constant "6 \273\326\270\264\304\254\310\317     16
     ?<Constant "Info">                                  8
     ?<Constant "     Select       Esc">                24
     ?<Constant "1 Memery Info">                        16
     ?<Constant "2 BlueTooth Info">                     20
     ?<Constant "3 Firmware Version">                   20
     ?<Constant "\317\265\315\263\320\305\317\242 "     12
     ?<Constant "1 \262\351\277\264\304\332\264\346     12
     ?<Constant "2 \300\266\321\300\320\305\317\242     12
     ?<Constant "3 \260\346\261\276\320\305\317\242     12
     ?<Constant "      Select      Esc">                24
     ?<Constant "1 Quantity Enter ">                    20
     ?<Constant "2 Add Time">                           12
     ?<Constant "3 Add  Date">                          12
     ?<Constant "4 Input Barcode">                      16
     ?<Constant "5 Database Query">                     20
     ?<Constant "6 Avoid Dunplication">                 24
     ?<Constant "7 Barcode Statistic">                  20
     ?<Constant "8 Transfer Confirm">                   20
     ?<Constant "9 Delete Scan Record">                 24
     ?<Constant "1 \312\375\301\277\302\274\310\353     12
     ?<Constant "2 \314\355\274\323\311\250\303\350     16
     ?<Constant "3 \314\355\274\323\311\250\303\350     16
     ?<Constant "4 \312\344\310\353\314\365\302\353     12
     ?<Constant "5 \312\375\276\335\277\342\262\351     16
     ?<Constant "6 \267\300\326\271\326\330\270\264     16
     ?<Constant "7 \314\365\302\353\315\263\274\306     12
     ?<Constant "8 \264\253\312\344\310\267\310\317     12
     ?<Constant "9 \307\345\263\375\311\250\303\350     16
     ?<Constant "Scan Mode">                            12
     ?<Constant "1 Good-read Off">                      16
     ?<Constant "2 Momentary">                          12
     ?<Constant "3 Continuous">                         16
     ?<Constant "\311\250\303\350\304\243\312\275 "     12
     ?<Constant "1 \265\245\264\316\260\264\274\374     16
     ?<Constant "2 \260\264\274\374\261\243\263\326     12
     ?<Constant "3 \301\254\320\370\311\250\303\350     12
     ?<Constant "Quantity Enter">                       16
     ?<Constant "1 Disable">                            12
     ?<Constant "2 Repeat Output ">                     20
     ?<Constant "3 Output Quantity">                    20
     ?<Constant "\312\375\301\277\302\274\310\353">     12
     ?<Constant "         \321\241\324\361    \315\     24
     ?<Constant "1 \271\330\261\325">                    8
     ?<Constant "2 \326\330\270\264\312\344\263\366     16
     ?<Constant "3 \312\344\263\366\314\365\302\353     16
     ?<Constant "Add Time">                             12
     ?<Constant "1 Disbale">                            12
     ?<Constant "2 Enable ">                            12
     ?<Constant "\314\355\274\323\312\261\274\344">     12
     ?<Constant "2 \277\252\306\364">                    8
     ?<Constant "Add Date">                             12
     ?<Constant "\314\355\274\323\310\325\306\332">     12
     ?<Constant "Yes               No ">                24
     ?<Constant "\312\307                \267\361">     24
     ?<Constant "Database Query">                       16
     ?<Constant "     Select      Esc">                 24
     ?<Constant "\312\375\276\335\277\342\262\351\3     12
     ?<Constant "        \321\241\324\361    \315\3     24
     ?<Constant "Avoid Dunplicaton">                    20
     ?<Constant "\267\300\326\271\326\330\270\264\3     16
     ?<Constant "Barcode Statistic">                    20
     ?<Constant "\314\365\302\353\315\263\274\306">     12
     ?<Constant "Transfer Confirm">                     20
     ?<Constant "\264\253\312\344\310\267\310\317">     12
     ?<Constant "Language">                             12
     ?<Constant "1 English">                            12
     ?<Constant "2 Simply Chinese">                     20
     ?<Constant "\323\357\321\324">                      8
     ?<Constant "1 \323\242\323\357">                    8
     ?<Constant "2 \274\362\314\345\326\320\316\304     12
     ?<Constant "Key Beeper">                           12
     ?<Constant "2 Enable">                             12
     ?<Constant "\260\264\274\374\322\364">              8
     ?<Constant "Timeout">                               8
     ?<Constant "2 30s">                                 8
     ?<Constant "3 60s">                                 8
     ?<Constant "4 2 minutes">                          12
     ?<Constant "5 5 minutes">                          12
     ?<Constant "\263\254\312\261\311\350\326\303">     12
     ?<Constant "2 30\303\353">                          8
     ?<Constant "3 60\303\353">                          8
     ?<Constant "4 2\267\326\326\323">                   8
     ?<Constant "5 5\267\326\326\323">                   8
     ?<Constant "BlueTooth">                            12
     ?<Constant "1 Offline Disable ">                   20
     ?<Constant "2 Offline Enable ">                    20
     ?<Constant "\300\266\321\300\304\243\312\275">     12
     ?<Constant "1 \315\321\273\372\264\346\264\242     16
     ?<Constant "2 \315\321\273\372\264\346\264\242     16
     ?<Constant "U Disk">                                8
     ?<Constant "1 Create new file">                    20
     ?<Constant "2 File list">                          12
     ?<Constant "3 Format">                             12
     ?<Constant "U\305\314">                             4
     ?<Constant "1 \264\264\275\250\320\302\316\304     16
     ?<Constant "2 \316\304\274\376\301\320\261\355     12
     ?<Constant "3 \270\361\312\275\273\257">           12
     ?<Constant "Offline Data">                         16
     ?<Constant "1 Send offline data">                  20
     ?<Constant "2 Interface">                          12
     ?<Constant "3 Batch Data Delete">                  20
     ?<Constant "\315\321\273\372\312\375\276\335\2     16
     ?<Constant "1 \267\242\313\315\315\321\273\372     16
     ?<Constant "2 \315\250\320\305\275\323\277\332     12
     ?<Constant "3 \307\345\263\375\315\321\273\372     16
     ?<Constant "Import Database">                      16
     ?<Constant "                  Esc">                24
     ?<Constant "\265\274\310\353\312\375\276\335\2     12
     ?<Constant "                 \315\313\263\366"     24
     ?<Constant "Barcode Setting">                      16
     ?<Constant "1 Decoder">                            12
     ?<Constant "2 Invalid offset">                     20
     ?<Constant "\314\365\302\353\311\350\326\303">     12
     ?<Constant "       \321\241\324\361      \315\     24
     ?<Constant "1 \275\342\302\353\306\367">           12
     ?<Constant "2 \323\320\320\247\316\273\311\350     16
     ?<Constant "Time/Date">                            12
     ?<Constant "Input             Esc">                24
     ?<Constant "Set Date/Time:">                       16
     ?<Constant "(YYYYMMDDHHMMSS)">                     20
     ?<Constant "\312\261\274\344\310\325\306\332">     12
     ?<Constant "\312\344\310\353             \315\     24
     ?<Constant "\311\350\326\303\310\325\306\332/\     16
     ?<Constant "Default Setting">                      16
     ?<Constant "Cancle          Enter">                24
     ?<Constant "\273\326\270\264\304\254\310\317\3     16
     ?<Constant "\310\241\317\373             \310\     24
     ?<Constant "System Password">                      16
     ?<Constant "\311\350\326\303\317\265\315\263\3     16
     ?<Constant "Decoder Setting">                      16
     ?<Constant "      On/Off     Esc">                 24
     ?<Constant "EAN8/13/128">                          12
     ?<Constant "UPCA/C/E/E1">                          12
     ?<Constant "Code39">                                8
     ?<Constant "Code93">                                8
     ?<Constant "Code11">                                8
     ?<Constant "Code128">                               8
     ?<Constant "Interleaved 2/5">                      16
     ?<Constant "Matrix 2/5">                           12
     ?<Constant "Industry 2/5">                         16
     ?<Constant "MSI">                                   4
     ?<Constant "RSS14/Limited/Ex">                     20
     ?<Constant "Chinapost">                            12
     ?<Constant "\275\342\302\353\306\367\311\350\3     12
     ?<Constant "       \277\252/\271\330     \315\     24
     ?<Constant "UPCA/E/E1">                            12
     ?<Constant "Invalid Offset">                       16
     ?<Constant "Input            Esc">                 24
     ?<Constant "Input BeginOff:">                      16
     ?<Constant "Input End Off:">                       16
     ?<Constant "\323\320\320\247\316\273\312\375">     12
     ?<Constant "\312\344\310\353\306\360\312\274\3     16
     ?<Constant "\312\344\310\353\275\341\312\370\3     16
     ?<Constant "Batch Trans">                          12
     ?<Constant "\315\321\273\372\312\375\276\335\2_1   16
     ?<Constant "                 \267\265\273\330"     24
     ?<Constant "Batch Trans Mode">                     20
     ?<Constant "\315\321\273\372\312\375\276\335\3     20
     ?<Constant "Batch clear">                          12
     ?<Constant "\274\307\302\274\307\345\263\375">     12
     ?<Constant "Record clear">                         16
     ?<Constant "Memory">                                8
     ?<Constant "\304\332\264\346\320\305\317\242">     12
     ?<Constant "About Bluetooth">                      16
     ?<Constant "\271\330\323\332\300\266\321\300">     12
     ?<Constant "Version">                               8
     ?<Constant "\260\346\261\276\320\305\317\242 "     12
     ?<Constant "New File">                             12
     ?<Constant "Input  Creat   Cancle">                24
     ?<Constant "Input file name:">                     20
     ?<Constant "Only Creat Txt File">                  20
     ?<Constant "\264\264\275\250\316\304\274\376">     12
     ?<Constant "\312\344\310\353    \310\267\266\2     24
     ?<Constant "\307\353\312\344\310\353\316\304\2     16
     ?<Constant "\304\254\310\317\275\250\301\242tx     16
     ?<Constant "File List">                            12
     ?<Constant "Options  Select  Esc ">                24
     ?<Constant "\316\304\274\376\301\320\261\355">     12
     ?<Constant "\321\241\317\356    \321\241\324\3     24
     ?<Constant "Format">                                8
     ?<Constant "Yes                No">                24
     ?<Constant "\270\361\312\275\273\257">              8
     ?<Constant "                 Esc">                 24
     ?<Constant "1 Clear file">                         16
     ?<Constant "2 Delete file">                        16
     ?<Constant "                \267\265\273\330">     24
     ?<Constant "1 \307\345\277\325\316\304\274\376     12
     ?<Constant "2 \311\276\263\375\316\304\274\376     12
     ?<Constant "Clear file">                           12
     ?<Constant "\307\345\277\325\316\304\274\376">     12
     ?<Constant "Delete file">                          12
     ?<Constant "\311\276\263\375\316\304\274\376">     12
     ?<Constant "\267\265\273\330">                      8
     ?<Constant "1.\271\244\263\247\262\342\312\324     12
     ?<Constant "2.\300\317\273\257\262\342\312\324     12
     ?<Constant "1.\311\250\303\350\300\317\273\257     16
     ?<Constant "2.\300\266\321\300\300\317\273\257     16
     ?<Constant "3.\311\250\303\350\264\253\312\344     16
     ?<Constant "1.\317\324\312\276\262\342\312\324     12
     ?<Constant "2.\274\374\305\314\262\342\312\324     12
     ?<Constant "3.\311\250\303\350\262\342\312\324     12
     ?<Constant "4.\300\266\321\300\262\342\312\324     12
     ?<Constant "5.USB\262\342\312\324">                12
     ?<Constant "6.RTC\262\342\312\324">                12
     ?<Constant "7.\265\347\263\330\265\347\321\271     16
     ?<Constant "                \310\267\310\317">     24
     ?<Constant "\260\264\317\302SCAN\274\374\326\2     24
     ?<Constant "     \327\366\317\324\312\276\274\     16
     ?<Constant "                    ">                 24
     ?<Constant "\324\331\264\316\260\264\317\302SC     24
     ?<Constant "\260\264\317\302\317\340\323\246\2     24
     ?<Constant "\274\374\303\373\276\315\273\341\3     24
     ?<Constant "\260\264\317\302SCAN\274\374\262\3     24
     ?<Constant "\260\264\317\302SCAN\274\374\262\3_1   20
     ?<Constant "\260\264\317\302SCAN\274\374\262\3_2   20
     ?<Constant "   ">                                   4
     ?<Constant "Todo">                                  8
     ?<Constant "Esc">                                   4
     ?<Constant "\264\375\312\265\317\326 ">             8
     ?<Constant "logo">                                  8
     ?<Constant "scan_func">                            12
     ?<Constant "data_transfer_func">                   20
     ?<Constant "terminal_setting">                     20
     ?<Constant "system_info">                          12
     ?<Constant "about_copyright">                      16
     ?<Constant "scan_option_menu">                     20
     ?<Constant "scan_mode_menu">                       16
     ?<Constant "quantity_enter_menu">                  20
     ?<Constant "add_time_option">                      16
     ?<Constant "add_date_option">                      16
     ?<Constant "input_barcode">                        16
     ?<Constant "input_send_num">                       16
     ?<Constant "seperator_setting">                    20
     ?<Constant "modify_num_ack">                       16
     ?<Constant "database_query_option">                24
     ?<Constant "avoid_dunplication_op...">             28
     ?<Constant "barcode_statistic_option">             28
     ?<Constant "transfer_confirm_option">              24
     ?<Constant "language_option">                      16
     ?<Constant "beeper_vol_option">                    20
     ?<Constant "timeout_option">                       16
     ?<Constant "transfer_bluetooth_op...">             28
     ?<Constant "transfer_u_disk_option">               24
     ?<Constant "transfer_batch_option">                24
     ?<Constant "import_database">                      16
     ?<Constant "barcode_option">                       16
     ?<Constant "time_date_setting">                    20
     ?<Constant "default_setting">                      16
     ?<Constant "set_system_password">                  20
     ?<Constant "decoder_setting">                      16
     ?<Constant "invalid_offset_setting">               24
     ?<Constant "batch_data_send">                      16
     ?<Constant "batch_transfer_mode">                  20
     ?<Constant "batch_data_clear">                     20
     ?<Constant "clear_scan_record">                    20
     ?<Constant "view_memery">                          12
     ?<Constant "bluetooth_info">                       16
     ?<Constant "firmware_info">                        16
     ?<Constant "create_new_file">                      16
     ?<Constant "file_list">                            12
     ?<Constant "u_disk_format">                        16
     ?<Constant "file_options_menu">                    20
     ?<Constant "clear_file_ack">                       16
     ?<Constant "delete_file_ack">                      16
     ?<Constant "test_menu">                            12
     ?<Constant "age_test_menu">                        16
     ?<Constant "single_test_menu">                     20
     ?<Constant "test_lcd_display">                     20
     ?<Constant "test_keypad">                          12
     ?<Constant "test_scaner_init">                     20
     ?<Constant "test_usb">                             12
     ?<Constant "test_rtc">                             12
     ?<Constant "test_AD">                               8
     ?<Constant "test_bluetooth">                       16
     ?<Constant "test_complete">                        16
     ?<Constant "todo">                                  8
     ?<Constant "V1.0.1">                                8
     ?<Constant "  Scan  ">                             12
     ?<Constant "  \311\250\303\350  ">                 12
     ?<Constant "Transfer">                             12
     ?<Constant "\312\375\276\335\264\253\312\344">     12
     ?<Constant "Setting">                               8
     ?<Constant "\317\265\315\263\311\350\326\303">     12
     ?<Constant "  Info  ">                             12
     ?<Constant "\317\265\315\263\320\305\317\242">     12
     ?<Constant "%d">                                    4
     ?<Constant "\r\n">                                  4
     ?<Constant "\000\000\000">                          4
     ?<Constant "Barcode duplication!">                 24
     ?<Constant "\314\365\302\353\322\321\264\346\3     12
     ?<Constant "No More Space">                        16
     ?<Constant "\264\346\264\242\322\321\264\357\3     16
     ?<Constant "Record Store fail!">                   20
     ?<Constant "\274\307\302\274\264\346\264\242\3     16
     ?<Constant "Databse isn\'t exist!">                24
     ?<Constant "\312\375\276\335\277\342\316\304\2     20
     ?<Constant "Please press\"SCAN\"...">              24
     ?<Constant "\307\353\260\264\"SCAN\"\274\374\3     20
     ?<Constant "Esc    Enter% 8d">                     20
     ?<Constant "\310\241\317\373    \310\267\310\3     20
     ?<Constant "Esc            Enter">                 24
     ?<Constant "\310\241\317\373            \310\2     24
     ?<Constant "**NO SPEC**">                          12
     ?<Constant "**\316\336\311\314\306\267\320\305     16
     ?<Constant "<%d         >">                        16
     ?<Constant "Esc     Enter      1">                 24
     ?<Constant "\310\241\317\373    \310\267\310\3_1   24
     ?<Constant "Options             ">                 24
     ?<Constant "\321\241\317\356                ">     24
     ?<Constant "Option">                                8
     ?<Constant "    ">                                  8
     ?<Constant "Check Device is Conne...">             28
     ?<Constant "\307\353\310\267\310\317\311\350\2     24
     ?<Constant "No Batch Data!">                       16
     ?<Constant "\303\273\323\320\315\321\273\372\3     16
     ?<Constant "Sending,Wait a minute">                24
     ?<Constant "\325\375\324\332\267\242\313\315,\     20
     ?<Constant "Send %d barcodes!">                    20
     ?<Constant "\267\242\313\315\301\313%d\314\365     16
     ?<Constant "Batch data will be de...">             36
     ?<Constant "\315\321\273\372\312\375\276\335\2_2   20
     ?<Constant "\312\307\267\361\274\314\320\370?"     12
     ?<Constant "Data delete fail!">                    20
     ?<Constant "\312\375\276\335\307\345\263\375\3     16
     ?<Constant "Data delete success!">                 24
     ?<Constant "\312\375\276\335\307\345\263\375\2     16
     ?<Constant "Scan record will be d...">             40
     ?<Constant "\311\250\303\350\274\307\302\274\2     20
     ?<Constant "Modify the number?">                   20
     ?<Constant "\310\267\266\250\320\336\270\304\3     16
     ?<Constant "Import Goods Info">                    20
     ?<Constant "\311\314\306\267\320\305\317\242\2     16
     ?<Constant "Fail">                                  8
     ?<Constant "Success">                               8
     ?<Constant "\312\247\260\334">                      8
     ?<Constant "\263\311\271\246">                      8
     ?<Constant "USB link disconnected">                24
     ?<Constant "USB\301\254\275\323\266\317\277\25     16
     ?<Constant "Command Error">                        16
     ?<Constant "\303\374\301\356\312\375\276\335\3     16
     ?<Constant "Connect USB link...">                  20
     ?<Constant "\307\353\301\254\275\323USB...">       16
     ?<Constant "Command Timeout!">                     20
     ?<Constant "\265\310\264\375\326\367\273\372\3     20
     ?<Constant "Download database...">                 24
     ?<Constant "\325\375\324\332\317\302\324\330\3     20
     ?<Constant "Waiting command...">                   20
     ?<Constant "\265\310\264\375\326\367\273\372\3_1   16
     ?<Constant "Invalid Time!">                        16
     ?<Constant "Re-input!">                            12
     ?<Constant "\312\344\310\353\312\261\274\344\2     16
     ?<Constant "\307\353\326\330\320\302\312\344\3     12
     ?<Constant "The operate will clea...">             48
     ?<Constant "\273\326\270\264\304\254\310\317\3_1   40
     ?<Constant "Invalid setting">                      16
     ?<Constant "\311\350\326\303\316\336\320\247">     12
     ?<Constant "\307\353\326\330\320\302\312\344\3_1   12
     ?<Constant "Remain %d free bytes,...">             36
     ?<Constant "\312\243\323\340%d\277\311\323\303     28
     ?<Constant "/">                                     2
     ?<Constant "KeyboardName:LSBTK001">                24
     ?<Constant "ProtocolVer:V2.0">                     20
     ?<Constant "\300\266\321\300\274\374\305\314\3     24
     ?<Constant "\300\266\321\300\320\255\322\351\2     20
     ?<Constant "Firmware:V1.0.0">                      16
     ?<Constant "App Ver:">                             12
     ?<Constant "Scanner:uE_2.3_1.5.29">                24
     ?<Constant "\271\314\274\376\260\346\261\276:V     16
     ?<Constant "\323\246\323\303\260\346\261\276:"     12
     ?<Constant "\311\250\303\350\315\267:uE_2.3_1.     24
     ?<Constant ".txt">                                  8
     ?<Constant "Create file fail!">                    20
     ?<Constant "\316\304\274\376\264\264\275\250\3     16
     ?<Constant "Create file success!">                 24
     ?<Constant "\316\304\274\376\264\264\275\250\2     16
     ?<Constant "\262\273\324\312\320\355\260\374\2     20
     ?<Constant "*">                                     2
     ?<Constant "\\">                                    2
     ?<Constant "|">                                     2
     ?<Constant "\"">                                    2
     ?<Constant "?">                                     2
     ?<Constant ">">                                     2
     ?<Constant "<">                                     2
     ?<Constant ".">                                     2
     ?<Constant ".TXT">                                  8
     ?<Constant "All the data will be ...">             40
     ?<Constant "\313\371\323\320\312\375\276\335\2     36
     ?<Constant "Formatting...">                        16
     ?<Constant "\325\375\324\332\270\361\312\275\2     24
     ?<Constant "Clear this file?">                     20
     ?<Constant "\310\267\266\250\307\345\277\325\2     16
     ?<Constant "Clear fail!">                          12
     ?<Constant "\316\304\274\376\307\345\277\325\3     16
     ?<Constant "Can\'t Del target file">               24
     ?<Constant "\262\273\304\334\311\276\263\375\3     24
     ?<Constant "Delete this file?">                    20
     ?<Constant "\310\267\266\250\311\276\263\375\2     16
     ?<Constant "Delete fail!">                         16
     ?<Constant "\316\304\274\376\311\276\263\375\3     16
     ?<Constant "\350\240\234\355\231\241\351\234\3     24
     ?<Constant "\350\240\234\355\212\227\340\237\3     16
     ?<Constant "\223\240\350\240\351\375\223\226\3     36
     ?<Constant "\357\275\341\352\371\340jmoowihbik     20
     ?<Constant "\222\267\346\244\214\242\215\255\2     20
     ?<Constant "\213\225\347\241\357\233\352\274\3     24
     ?<Constant {&"\350\240\234\355\231\241\351\234     24
     ?<Constant "\314\365\302\353(S):">                 12
     ?<Constant "\263\311\271\246\264\316\312\375:"     12
     ?<Constant "\264\355\316\363\264\316\312\375:"     12
     ?<Constant "\300\266\321\300\304\243\277\351\3     16
     ?<Constant "\265\310\264\375\326\367\273\372\3_2   20
     ?<Constant "\310\267\310\317\312\307\267\361\3     20
     ?<Constant "\311\250\303\350\264\316\312\375:"     12
     ?<Constant "\264\253\312\344\264\316\312\375:"     12
     ?<Constant "                     ...">             36
     ?<Constant "\301\254\275\323\263\311\271\246!"     12
     ?<Constant "\260\264[scan]\275\370\320\320\312     24
     ?<Constant "\325\375\324\332\275\370\320\320\3     20
     ?<Constant "\r">                                    2
     ?<Constant "\301\254\275\323\266\317\277\252!"     12
     ?<Constant "\312\375\276\335\264\253\312\344\2     24
     ?<Constant "\301\254\275\323\326\320\266\317!"     12
     ?<Constant "POWER">                                 8
     ?<Constant "[-] ESC ENTER [-]">                    20
     ?<Constant "LEFT UP RIGHT DOWN">                   20
     ?<Constant "      SCAN">                           12
     ?<Constant "\314\365\302\353\300\340\320\315:"     12
     ?<Constant "\301\254\275\323USB\317\337!">         12
     ?<Constant "\265\310\264\375\326\320">              8
     ?<Constant "...">                                   4
     ?<Constant ".  ">                                   4
     ?<Constant ".. ">                                   4
     ?<Constant "                   ">                  20
     ?<Constant "USB\301\254\275\323\263\311\271\24     16
     ?<Constant "RTC \271\244\327\367\325\375\263\2     16
     ?<Constant "RTC \271\244\327\367\264\355\316\3     16
     ?<Constant "AD\262\311\321\371\325\375\263\243     12
     ?<Constant "AD\262\311\321\371\264\355\316\363     12

 
    750 bytes in section .bss
  1 996 bytes in section .data
 10 630 bytes in section .rodata
 17 550 bytes in section .text
 
 17 508 bytes of CODE  memory (+ 42 bytes shared)
 10 630 bytes of CONST memory
  2 746 bytes of DATA  memory

Errors: none
Warnings: 115
