###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.30.2.51295/W32 for ARM     31/Mar/2014  10:27:52 #
# Copyright 1999-2009 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\work\T6\FW\src\Drivers\uE988_scan.c                   #
#    Command line =  D:\work\T6\FW\src\Drivers\uE988_scan.c -lcN              #
#                    D:\work\T6\FW\src\Project\EWARMv5\Debug\List\ -o         #
#                    D:\work\T6\FW\src\Project\EWARMv5\Debug\Obj\ --no_cse    #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    5.4\arm\INC\DLib_Config_Full.h" -I                       #
#                    D:\work\T6\FW\src\Project\EWARMv5\..\ -I                 #
#                    D:\work\T6\FW\src\Project\EWARMv5\..\..\App\ -I          #
#                    D:\work\T6\FW\src\Project\EWARMv5\..\..\Drivers\ -I      #
#                    D:\work\T6\FW\src\Project\EWARMv5\..\..\FatFs\ -I        #
#                    D:\work\T6\FW\src\Project\EWARMv5\..\..\Lib\inc\ -I      #
#                    D:\work\T6\FW\src\Project\EWARMv5\..\..\uCOS\uC-CPU\ -I  #
#                    D:\work\T6\FW\src\Project\EWARMv5\..\..\uCOS\uC-LIB\ -I  #
#                    D:\work\T6\FW\src\Project\EWARMv5\..\..\uCOS\uCOS-II\Por #
#                    ts\ -I D:\work\T6\FW\src\Project\EWARMv5\..\..\uCOS\uCOS #
#                    -II\Source\ -I D:\work\T6\FW\src\Project\EWARMv5\..\..\u #
#                    COS\uC-Probe\ -I D:\work\T6\FW\src\Project\EWARMv5\..\.. #
#                    \usb_lib\ -I "C:\Program Files\IAR Systems\Embedded      #
#                    Workbench 5.4\arm\INC\" -Ol                              #
#    List file    =  D:\work\T6\FW\src\Project\EWARMv5\Debug\List\uE988_scan. #
#                    lst                                                      #
#    Object file  =  D:\work\T6\FW\src\Project\EWARMv5\Debug\Obj\uE988_scan.o #
#                                                                             #
#                                                                             #
###############################################################################

D:\work\T6\FW\src\Drivers\uE988_scan.c
      1          /**
      2          * @file  uE988_scan.c
      3          * @brief uE988 Scan Engine 条码扫描仪的驱动模块
      4          * @version 1.0
      5          * @author yinzh
      6          * @date 2011年01月24日
      7          * @note
      8          */
      9          #include <string.h>
     10          #include "stm32f10x_lib.h"
     11          #include "ucos_ii.h"
     12          #include "uE988_scan.h"
     13          #include "TimeBase.h"
     14          #include "keypad.h"
     15          //#include "gui.h"
     16          #include "PCUsart.h"
     17          #include "uart_drv.h"
     18          
     19          //#define UE988_DEBUG
     20          
     21          /**************	命令代码(Op_code)	**********************/
     22          #define		BEEP						0xE6
     23          #define		CMD_ACK						0xD0
     24          #define		CMD_NAK						0xD1
     25          #define		DECODE_DATA					0xF3
     26          #define		EVENT						0xF6
     27          #define		LED_OFF						0xE8
     28          #define		LED_ON						0xE7
     29          #define		PARAM_DEFAULTS				0xC8
     30          #define		PARAM_REQUEST				0xC7
     31          #define		PARAM_SEND					0xC6
     32          #define		REPLY_REVISION				0xA4
     33          #define		REQUEST_REVISION			0xA3
     34          #define		SCAN_DISABLE				0xEA
     35          #define		SCAN_ENABLE					0xE9
     36          #define		SLEEP						0xE8
     37          #define		START_DECODE				0xE4
     38          #define		STOP_DECODE					0xE5
     39          #define		CUSTOM_DEFAULTS				0x12
     40          
     41          #define		RES_CHECKFAILURE			1
     42          #define		RES_UNKOWN_MSG				2
     43          #define		RESPONSE_SUCCESS			3
     44          #define		RESPONSE_ACK				4
     45          #define		RESPONSE_NAK				5
     46          
     47          //条码类型代号与类型名称的对应结构体
     48          typedef struct  
     49          {
     50          	unsigned char type;
     51          	unsigned char *name;
     52          }TCodeTypeName;
     53          
     54          static unsigned char	g_ack_enable;							//indicate whether ack/nck handshaking is enabled  1: enable; 0: disable
     55          #define MAX_DECODE_DATA		50
     56          //static unsigned char	g_decode_data[MAX_DECODE_DATA];
     57          
     58          TUE988Command	g_resCmd;		//scan decoder -> host
     59          unsigned char	*g_pReqCmd;		//host -> scan decoder
     60          
     61          const	unsigned char	host_ack[6] = {0x04, CMD_ACK, 0x04, 0x0, 0xFF, 0x28};
     62          
     63          static	unsigned char scaner_version[21];		//扫描头版本
     64          static	unsigned int	wait_time_out;			//get_barcode命令的等待超时设置
     65          static  unsigned int    scanner_baudrate;
     66          
     67          TCodeTypeName code_type_name_tbl[] = {
     68          	{0x01, "Code 39"}, {0x02, "Codabar"}, {0x03, "Code 128"},
     69          	{0x04, "Discrete 2"}, {0x05, "IATA 2"}, {0x06, "Interleaved 2 of 5"},
     70          	{0x07, "Code 93"}, {0x08, "UPC A"}, {0x48, "UPC A 2S"},
     71          	{0x88, "UPC A 5S"}, {0x09, "UPC E0"}, {0x49, "UPC E0 2S"},
     72          	{0x89, "UPC E0 5S"}, {0x0A, "EAN 8"}, {0x0B, "EAN 13"},
     73          	{0x4B, "EAN 13 2S"}, {0x8B, "EAN 13 5S"}, {0x0E, "MSI"},
     74          	{0x0F, "EAN 128"}, {0x10, "UPC E1"}, {0x50, "UPC E1 2S"},
     75          	{0x90, "UPC E1 5S"}, {0x15, "Tp Code 39"}, {0x23, "RSS-Limit"},
     76          	{0x24, "RSS-14"}, {0x25, "RSS-Expanded"},{0x13,"UK"},{0x11,"China Post"},
     77          	{0x0c,"Code 11"},{0x0d,"Matrix 2 0f 5"}, {0, 0}
     78          };
     79          
     80          //TCodeTypeName code_type_name_tbl_OldVersion[] = {
     81          //	{0x01, "Code 39"}, {0x02, "Codabar"}, {0x03, "Code 128"},
     82          //	{0x04, "Discrete 2"}, {0x05, "IATA 2"}, {0x06, "Interleaved 2 of 5"},
     83          //	{0x07, "Code 93"}, {0x08, "UPC A"}, {0x48, "UPC A 2S"},
     84          //	{0x88, "UPC A 5S"}, {0x09, "UPC E0"}, {0x49, "UPC E0 2S"},
     85          //	{0x89, "UPC E0 5S"}, {0x0A, "EAN 8"}, {0x0B, "EAN 13"},
     86          //	{0x4B, "EAN 13 2S"}, {0x8B, "EAN 13 5S"}, {0x0E, "MSI"},
     87          //	{0x0F, "EAN 128"}, {0x10, "UPC E1"}, {0x50, "UPC E1 2S"},
     88          //	{0x90, "UPC E1 5S"}, {0x15, "Tp Code 39"}, {0x23, "RSS-Limit"},
     89          //	{0x24, "RSS-14"}, {0x25, "RSS-Expanded"},{0x13,"UK"},{0x11,"China Post"},
     90          //	{0x0c,"Code 11"},{0x0d,"Matrix 2 0f 5"}, {0, 0}
     91          //};
     92          
     93          //unsigned int	scan_start;
     94          
     95          static int write_cmd_to_scanner(const unsigned char *pData, unsigned short length);
     96          static void pack_command(unsigned char cmd_code, unsigned char cmd_status, unsigned char *pCmddata, unsigned char data_len);
     97          
     98          
     99          ///* 
    100          //* @brief: 控制支持/不支持某种条码
    101          //* @param[in] codeType: 条码代号，见以上的宏定义
    102          //*				 ctrl: 只能取ENABLE 或 DISABLE
    103          //* @note: 
    104          //*/
    105          //int UE988_codeType_ctrl(unsigned char codeType, unsigned char ctrl)
    106          //{
    107          //	unsigned char req_data[8] = {0};
    108          //	unsigned char cur_pos = 0;
    109          //
    110          //	req_data[cur_pos++] = 0xFF;	//beep code
    111          //	if (codeType == ChinaPost || codeType == RSS14 ||
    112          //		codeType == RSSLimited || codeType == RSSExpanded)
    113          //	{
    114          //		req_data[cur_pos++] = 0xF0;
    115          //	}
    116          //	req_data[cur_pos++] = codeType;
    117          //	req_data[cur_pos++] = ctrl;
    118          //	pack_command(PARAM_SEND, 0x08, req_data, cur_pos);
    119          //	if (write_cmd_to_scanner(g_pReqCmd, strlen(g_pReqCmd)) == 0)
    120          //	{
    121          //		return 0;
    122          //	}
    123          //
    124          //	return -1;
    125          //}
    126          
    127          
    128          /* 
    129          * @brief: 开启/关闭某种条码类型
    130          * @param[in] codeType: 条码类型代号，见宏定义
    131          *				 ctrl: 只能为ENABLE 或 DISABLE
    132          * @note: 默认情况下， code 11  code93
    133          China Post
    134          Codabar
    135          MSI
    136          RSS系列(RSS-14 RSS-Limited RSS-Expanded)都是关闭的
    137          */
    138          int UE988_codeType_ctrl(unsigned char codeType, unsigned char ctrl)
    139          {
    140          	unsigned char req_data[8] = {0};
    141          	unsigned char cur_pos = 0;
    142          
    143          	req_data[cur_pos++] = 0xFF;	//beep code
    144          	if (codeType == ChinaPost || codeType == RSS14 ||
    145          		codeType == RSSLimited || codeType == RSSExpanded)
    146          	{
    147          		req_data[cur_pos++] = 0xF0;
    148          	}
    149          	else if (codeType == Matrix20f5 || codeType == UK)
    150          	{
    151          		req_data[cur_pos++] = 0xF2;
    152          	}
    153          
    154          	req_data[cur_pos++] = codeType;
    155          	req_data[cur_pos++] = ctrl;
    156          	pack_command(PARAM_SEND, 0x08, req_data, cur_pos);
    157          	if (write_cmd_to_scanner(g_pReqCmd, strlen(g_pReqCmd)) == 0)
    158          	{
    159          		return 0;
    160          	}
    161          
    162          	return -1;
    163          }
    164          
    165          /* 
    166          * @brief: 各种条码的参数设置
    167          * @param[in] unsigned char *param: 需设置的参数命令 
    168          */
    169          int UE988_set_codeParam(unsigned char *param, unsigned char param_len)
    170          {
    171          	unsigned char req_data[16] = {0};
    172          
    173          	if (param_len > 15)
    174          	{
    175          		return -1;
    176          	}
    177          
    178          	req_data[0] = 0xFF;		//beep code
    179          	memcpy(req_data+1, param, param_len);
    180          
    181          	pack_command(PARAM_SEND, 0x08, req_data, param_len+1);
    182          	if (write_cmd_to_scanner(g_pReqCmd, strlen(g_pReqCmd)) == 0)
    183          	{
    184          		return 0;
    185          	}
    186          
    187          	return -1;
    188          }
    189          
    190          
    191          /**
    192          * @brief 根据类型代号获取类型名称
    193          * @param[in] unsigned char type 类型代号
    194          * @return unsigned char * name 类型名称
    195          */
    196          static unsigned char *type2name(unsigned char type)
    197          {
    198          	unsigned int i = 0;
    199          
    200          	if(type == 0)
    201          		return 0;
    202          
    203          	while (code_type_name_tbl[i].type != 0) 
    204          	{
    205          		if (type == code_type_name_tbl[i].type) 
    206          		{
    207          			return code_type_name_tbl[i].name;
    208          		}
    209          		i++;
    210          	}
    211          	return 0;
    212          }
    213          /*
    214           * @brief: 初始化模块端口
    215          */
    216          static void UE988_GPIO_config(unsigned int baudrate)
    217          {
    218          	GPIO_InitTypeDef				GPIO_InitStructure;
    219          	USART_InitTypeDef				USART_InitStructure;
    220          
    221          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC | RCC_APB2Periph_AFIO, ENABLE);
    222          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
    223          
    224          	//Power
    225          	GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_8;
    226                  GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_50MHz;
    227          	GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_Out_PP;
    228          	GPIO_Init(GPIOC, &GPIO_InitStructure);
    229          	GPIO_SetBits(GPIOC, GPIO_Pin_8);
    230          
    231          	// 使用UART3, PB10,PB11
    232          	/* Configure USART3 Tx (PB.10) as alternate function push-pull */
    233          	GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_10;
    234          	GPIO_InitStructure.GPIO_Speed			= GPIO_Speed_50MHz;
    235          	GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_AF_PP;
    236          	GPIO_Init(GPIOB, &GPIO_InitStructure);
    237          
    238          	/* Configure USART3 Rx (PB.11) as input floating				*/
    239          	GPIO_InitStructure.GPIO_Pin				= GPIO_Pin_11;
    240          	GPIO_InitStructure.GPIO_Mode			= GPIO_Mode_IN_FLOATING;
    241          	GPIO_Init(GPIOB, &GPIO_InitStructure);
    242          
    243          	USART_InitStructure.USART_BaudRate		= baudrate;					
    244          	USART_InitStructure.USART_WordLength	= USART_WordLength_8b;
    245          	USART_InitStructure.USART_StopBits		= USART_StopBits_1;
    246          	USART_InitStructure.USART_Parity		= USART_Parity_No;
    247          	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    248          	USART_InitStructure.USART_Mode			= USART_Mode_Rx | USART_Mode_Tx;
    249          
    250          	USART_Init(USART3, &USART_InitStructure);
    251          	USART_Cmd(USART3, ENABLE);
    252          }
    253          
    254          static void UE988_NVIC_config(void)
    255          {
    256          	NVIC_InitTypeDef NVIC_InitStructure;
    257          	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);
    258          
    259          	/* Enable the USART1 Interrupt */
    260          	NVIC_InitStructure.NVIC_IRQChannel				=USART3_IRQChannel;
    261          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority	= 0;
    262          	//NVIC_InitStructure.NVIC_IRQChannelSubPriority	= 1;
    263          	NVIC_InitStructure.NVIC_IRQChannelCmd			= ENABLE;
    264          	NVIC_Init(&NVIC_InitStructure);
    265          
    266          	USART_ClearITPendingBit(USART3, USART_IT_RXNE); 
    267          	USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);
    268          }
    269          
    270          static void reset_resVar(void)
    271          {
    272          	g_resCmd.CmdPos = 0;
    273          	g_resCmd.DataLength = 0;
    274          	g_resCmd.status	 = 0;
    275          }
    276          
    277          /*
    278          *brief: 硬件唤醒扫描仪
    279          */
    280          #if 0
    281          static void hardware_wakeup(void)
    282          {
    283          	int i = 0;
    284          
    285          	GPIO_ResetBits(GPIOA, GPIO_Pin_6);
    286          	for (i = 0; i < 1000; i++)
    287          	{
    288          		;
    289          	}
    290          
    291          	GPIO_SetBits(GPIOA, GPIO_Pin_6);
    292          }
    293          #endif
    294          /**
    295          * @brief  发数据给条形码扫描仪
    296          * @param[in] unsigned char *pData 要发送的数据
    297          * @param[in] int length 要发送数据的长度
    298          */
    299          static void send_data_to_scanner(const unsigned char *pData, unsigned short length)
    300          {
    301          	while(length--)
    302          	{
    303          		USART_SendData(USART3, *pData++);
    304          		while(USART_GetFlagStatus(USART3, USART_FLAG_TXE) == RESET)
    305          		{
    306          		}
    307          	}
    308          	while(USART_GetFlagStatus(USART3, USART_FLAG_TC) == RESET){};
    309          }
    310          
    311          /**
    312          * @brief  发命令给条形码扫描仪
    313          * @param[in] unsigned char *pData 要发送的数据
    314          * @param[in] int length 要发送数据的长度
    315          * @param[out]	0: 成功
    316          *				-1: 失败
    317          */
    318          static int write_cmd_to_scanner(const unsigned char *pData, unsigned short length)
    319          {
    320          	unsigned char	retry_times		= 2;
    321          
    322          	UE988_wakeup();		//先唤醒模块
    323          
    324          loop:
    325          	retry_times--;
    326          	send_data_to_scanner(pData, length);
    327          
    328          	if (g_ack_enable == 0)	//ack/nak handshaking disabled
    329          	{
    330          		return 0;
    331          	}
    332          
    333          	//wait host ack
    334          	reset_resVar();
    335          	StartDelay(200);			/* 延时1S		*/
    336          	while (DelayIsEnd() != 0)
    337          	{
    338          		if (g_resCmd.status == RESPONSE_ACK)
    339          		{
    340          			return 0;
    341          		}
    342          		else if (g_resCmd.status == RESPONSE_NAK)
    343          		{
    344          			return -1;
    345          		}
    346          	}
    347          	if (retry_times == 0)
    348          	{
    349          		return -1;
    350          	}
    351          	goto	loop;
    352          }
    353          
    354          static unsigned short calc_checksum(unsigned char *pData, unsigned char data_len)
    355          {
    356          	unsigned int i = 0;
    357          	unsigned short checksum = 0;
    358          
    359          	for (i = 0; i < data_len; i++)
    360          	{
    361          		checksum	+= pData[i];
    362          	}
    363          
    364          	checksum	= ~checksum;
    365          	checksum	+= 1;
    366          
    367          	return checksum;
    368          }
    369          
    370          /**
    371          * @brief  打包命令(host->scanner)
    372          * @param[in] unsigned char cmd_code 命令代码
    373          * @param[in] unsigned char cmd_status 
    374          * @param[in] unsigned char *pCmddata 命令数据
    375          * @param[in] unsigned char data_len 命令数据长度
    376          * @note: 命令格式
    377          *	---------------------------------------------------------------
    378          *  | length | Op-code | Message Source | Status | Data | Checksum |
    379          *	---------------------------------------------------------------
    380          */
    381          static void pack_command(unsigned char cmd_code, unsigned char cmd_status, unsigned char *pCmddata, unsigned char data_len)
    382          {
    383          	unsigned short cur_pos	= 0;
    384          	unsigned short checksum = 0;
    385                  
    386                  memset(g_pReqCmd,0,50);
    387          
    388          	g_pReqCmd[cur_pos]	= 4 + data_len;		//length
    389          	cur_pos++;
    390          	g_pReqCmd[cur_pos] = cmd_code;			//Op_code
    391          	cur_pos++;
    392          	g_pReqCmd[cur_pos] = 0x04;				// Message Source
    393          	cur_pos++;
    394          	g_pReqCmd[cur_pos]	= cmd_status;		//Status
    395          	cur_pos++;
    396          
    397          	if (data_len > 0 && pCmddata != 0)
    398          	{
    399          		memcpy(g_pReqCmd+cur_pos, pCmddata, data_len);		//Data
    400          		cur_pos		+=	data_len;
    401          	}
    402          
    403          	checksum = calc_checksum(g_pReqCmd, cur_pos);
    404          	g_pReqCmd[cur_pos] = (checksum>>8)&0xFF;
    405          	cur_pos++;
    406          	g_pReqCmd[cur_pos] = checksum&0xFF;
    407          }
    408          
    409          static void	send_ack_to_scanner(void)
    410          {
    411          	send_data_to_scanner(host_ack, 6);
    412          }
    413          
    414          /*
    415          * @param[in] cause	RES_CHECKFAILURE			
    416          *					RES_UNKOWN_MSG
    417          */
    418          static void send_nak_to_sanner(unsigned char cause)
    419          {
    420          	unsigned short checksum;
    421          	unsigned char	host_nak[7] = {0x05, CMD_NAK, 0x04, 0x0, 0x0, 0x0, 0x0};
    422          
    423          	host_nak[4]	= cause;
    424          	checksum = calc_checksum(host_nak, 5);
    425          	host_nak[5]	= (checksum>>8)&0xFF;
    426          	host_nak[6] = (checksum&0xFF);
    427          	send_data_to_scanner(host_nak, 7);
    428          }
    429          
    430          
    431          static int set_UE_param_default(void)
    432          {
    433          	unsigned char cmd_buf[] = {0x04, 0xD8, 0x04, 0x00, 0xFF, 0x20};
    434          
    435          	if (write_cmd_to_scanner(cmd_buf, 6) == 0)
    436          	{
    437          		return 0;
    438          	}
    439          
    440          	return -1;
    441          }
    442          /* 
    443          * @brief: 将模块Trigger Mode设为 Host模式
    444          * @note: 仅仅在第一次使用模块时设置，以后会永远保存
    445          */
    446          static int switch_to_Host_Mode(void)
    447          {
    448          	unsigned char param_num = 0x8A;
    449          	unsigned char cmd_buf[] = {0x07, 0xC6, 0x04, 0x08, 0x00, 0x8A, 0x08, 0xFE, 0x95};
    450          	int cur_mode = 0;
    451          
    452          	/* step 1: 先查询trigger mode, 如果为0x08, 则表明已经是Host 模式, 否则, 就修改 */
    453          	cur_mode = UE988_get_curParam(param_num);
    454          	if (cur_mode == -1 || cur_mode == -2)
    455          	{
    456          		return cur_mode;    //返回错误码， -2：表示响应超时，可能是波特率错误，或者扫描头损坏，未安装
    457          	}
    458          
    459          	if (cur_mode == 0x08)	//已经是Host模式
    460          	{
    461          		return 0;
    462          	}
    463          
    464          	//将参数设置为MD默认参数
    465          	OSTimeDlyHMSM(0,0,0,500);
    466          	set_UE_param_default();
    467          	OSTimeDlyHMSM(0,0,0,500);
    468          
    469          	/* step 2:  将模式修改成为Host模式			*/
    470          	if (write_cmd_to_scanner(cmd_buf, 9) == 0)
    471          	{
    472          		return 0;
    473          	}
    474          
    475          	return -1;
    476          }
    477          
    478          /* 
    479          * @brief: 将decode data packet format 设置为Packed Data, 默认为Data only模式
    480          * @note: 仅仅在第一次使用模块时设置，以后会永远保存
    481          */
    482          static int set_decode_data_format(void)
    483          {
    484          	unsigned char param_num = 0xEE;
    485          	unsigned char cmd_buf[] = {0x07, 0xC6, 0x04, 0x08, 0x00, 0xEE, 0x01, 0xFE, 0x38};
    486          	int cur_mode = 0;
    487          
    488          	/* step 1: 先查询trigger mode, 如果为0x08, 则表明已经是Host 模式, 否则, 就修改 */
    489          	cur_mode = UE988_get_curParam(param_num);
    490          	if (cur_mode == -1)
    491          	{
    492          		return -1;
    493          	}
    494          	if (cur_mode == 0x01)	//已经是packed data
    495          	{
    496          		return 0;
    497          	}
    498          
    499          	/* step 2:  将模式修改成为Host模式			*/
    500          	OSTimeDlyHMSM(0,0,0,500);
    501          	if (write_cmd_to_scanner(cmd_buf, 9) == 0)
    502          	{
    503          		return 0;
    504          	}
    505          
    506          	return -1;
    507          }
    508          
    509          /*
    510          * @breif: 初始化一些参数
    511          */
    512          static int UE988_Init_param(void)
    513          {
    514          	int   ret;
    515          	//将trigger mode 设为 host
    516          	ret = switch_to_Host_Mode();
    517          	if(ret == -2)
    518          	{
    519          		//响应超时，可以尝试切换主机的波特率，再次尝试一次
    520          		UE988_GPIO_config(115200);
    521          
    522          		ret = switch_to_Host_Mode();
    523          		if(ret)
    524          		{
    525          			return ret;
    526          		}
    527          		else
    528          		{
    529          			scanner_baudrate = 115200;
    530          		}
    531          	}
    532          	else
    533          	{
    534          		scanner_baudrate = 9600;
    535          	}
    536          
    537          	//设置Decode Data Packet Format 为Packed Data
    538          	set_decode_data_format();
    539          
    540          	//将默认打开的扫描到条码之后的蜂鸣功能关闭
    541          	UE988_set_curParam(0x38,0,1);
    542          
    543          	if(scanner_baudrate == 115200)
    544          	{
    545          	  UE988_set_curParam(0x9C,0x06,1);    //将扫描头的波特率设置为9600 
    546          	 UE988_GPIO_config(9600);
    547          	}
    548          
    549          	return 0;
    550          }
    551          
    552          //设置扫描头的解码器开关
    553          void UE988_set_decoder_switch(unsigned short switch_map)
    554          {
    555          	UE988_codeType_ctrl(EAN8,((switch_map&(0x0001<<0))?ENABLE:DISABLE));
    556          	UE988_codeType_ctrl(EAN13,((switch_map&(0x0001<<0))?ENABLE:DISABLE));
    557          	UE988_codeType_ctrl(UCCEAN128,((switch_map&(0x0001<<0))?ENABLE:DISABLE));
    558          
    559          	UE988_codeType_ctrl(UPCA,((switch_map&(0x0001<<1))?ENABLE:DISABLE));
    560          	UE988_codeType_ctrl(UPCE,((switch_map&(0x0001<<1))?ENABLE:DISABLE));
    561          	UE988_codeType_ctrl(UPCE1,((switch_map&(0x0001<<1))?ENABLE:DISABLE));
    562          
    563          	UE988_codeType_ctrl(Code39,((switch_map&(0x0001<<2))?ENABLE:DISABLE));
    564          
    565          	UE988_codeType_ctrl(Code93,((switch_map&(0x0001<<3))?ENABLE:DISABLE));
    566          
    567          	UE988_codeType_ctrl(Code11,((switch_map&(0x0001<<4))?ENABLE:DISABLE));
    568          
    569          	UE988_codeType_ctrl(Code128,((switch_map&(0x0001<<5))?ENABLE:DISABLE));
    570          
    571          	UE988_codeType_ctrl(IL2of5,((switch_map&(0x0001<<6))?ENABLE:DISABLE));
    572          
    573          	UE988_codeType_ctrl(Matrix20f5,((switch_map&(0x0001<<7))?ENABLE:DISABLE));
    574          
    575          	UE988_codeType_ctrl(InDus2of5,((switch_map&(0x0001<<8))?ENABLE:DISABLE));
    576          
    577          	UE988_codeType_ctrl(MSI,((switch_map&(0x0001<<9))?ENABLE:DISABLE));
    578          
    579          	UE988_codeType_ctrl(RSS14,((switch_map&(0x0001<<10))?ENABLE:DISABLE));
    580          	UE988_codeType_ctrl(RSSLimited,((switch_map&(0x0001<<10))?ENABLE:DISABLE));
    581          	UE988_codeType_ctrl(RSSExpanded,((switch_map&(0x0001<<10))?ENABLE:DISABLE));
    582          
    583          	UE988_codeType_ctrl(ChinaPost,((switch_map&(0x0001<<11))?ENABLE:DISABLE));
    584          }
    585          /*
    586          * @brief: 模块初始化
    587          */
    588          void UE988_Init(unsigned short switch_map)
    589          {
    590          	unsigned int	tmp;
    591          	//unsigned char IL2of5_len[5] = {0x16, 0x01, 0x17, 0x20};
    592          	//unsigned char Indus2of5_len[5] = {0x14, 0x01, 0x15, 0x20};
    593          	//unsigned char MSI_len[5] = {0x1E, 0x01, 0x1F, 0x20};
    594          	//unsigned char MSI_checkTrans[3] = {0x2E, 0x01};
    595          	
    596          
    597          	UE988_GPIO_config(9600);
    598          	UE988_NVIC_config();
    599          	
    600          	g_pReqCmd	= g_send_buff;
    601          	g_resCmd.CmdBuffer	= g_receive_buff;
    602          
    603          	reset_resVar();
    604          	g_ack_enable	= 1;
    605          
    606          
    607          	//初始化串口配置
    608          	Comm_SetReceiveProc(COMM3, (CommIsrInByte)UE988_RxISRHandler);						//设置串口回调函数
    609          
    610          #ifndef UE988_DEBUG
    611          	if(UE988_Init_param())
    612          	{
    613          		return;
    614          	}
    615          
    616          	//code 11
    617          	//China Post
    618          	//Codabar
    619          //MSI
    620          //RSS系列(RSS-14 RSS-Limited RSS-Expanded)
    621          	//这些条码类型的支持默认是关闭的，需要打开对他们的支持
    622          #if 1
    623          
    624          	UE988_set_decoder_switch(switch_map);
    625          	//UE988_codeType_ctrl(Code11,ENABLE);
    626          	//UE988_codeType_ctrl(ChinaPost,ENABLE);
    627          	//UE988_codeType_ctrl(Codabar,ENABLE);
    628          	//UE988_codeType_ctrl(MSI,ENABLE);
    629          	//UE988_codeType_ctrl(RSS14,ENABLE);
    630          	//UE988_codeType_ctrl(RSSLimited,ENABLE);
    631          	//UE988_codeType_ctrl(RSSExpanded,ENABLE);
    632          	//UE988_codeType_ctrl(Code93,ENABLE);
    633          	//UE988_codeType_ctrl(IL2of5,ENABLE);
    634          	//UE988_codeType_ctrl(TriopCode39, ENABLE);
    635          
    636          	//UE988_codeType_ctrl(InDus2of5, ENABLE);
    637          	//UE988_codeType_ctrl(UPCE1, ENABLE);
    638          
    639          	UE988_set_codeParam("\x16\x01\x17\x20", 4);				//UE988_set_codeParam(IL2of5_len, 4);
    640          	UE988_set_codeParam("\x14\x01\x15\x20", 4);				//UE988_set_codeParam(Indus2of5_len, 4);
    641          	//UE988_set_codeParam("\x1e\x01\x1f\x20", 4);				//UE988_set_codeParam(MSI_len, 4);
    642          	//UE988_set_codeParam("\x2e\x01", 2);						//UE988_set_codeParam(MSI_checkTrans, 2);
    643          
    644          	write_cmd_to_scanner("\x07\xC6\x04\x08\x00\x34\x00\xFE\xF3", 9);
    645          
    646          #endif
    647          
    648          	//Comm_InitPort(COMM3,9600, 0);									//配置串口参数  串口参数已经配置
    649          
    650          	//wait_time_out = 29;
    651          	//if(0 == UE988_get_softVersion(scaner_version,(unsigned char*)&tmp))
    652          	//{
    653          	//	if (memcmp(scaner_version,"uE_HW",5) == 0)
    654          	//	{
    655          	//		//明德的扫描头版本号是：uE_HW2.3_SW1.5.29_HY
    656          	//		//另外一款扫描头的版本号是:NBRSYPAC(D)...
    657          	//		wait_time_out = 48;
    658          	//	}
    659          	//}
    660          
    661          	wait_time_out = 48;
    662          #endif
    663          	//scan_start = 0;
    664          }
    665          
    666          
    667          /**
    668          * @brief 处理host收到scanner的数据
    669          * @param[in] unsigned char c 读入的字符
    670          * @return 0:success put in buffer
    671          *        -1:fail
    672          */
    673          int UE988_RxISRHandler(unsigned char c)
    674          {
    675          	unsigned short checksum = 0;
    676          
    677          		g_resCmd.CmdBuffer[g_resCmd.CmdPos++] = c;
    678          
    679          #ifdef UE988_DEBUG
    680          
    681          		if (g_resCmd.CmdPos == 20)
    682          		{
    683          			g_resCmd.CmdPos = 0;
    684          			g_resCmd.status	= RESPONSE_SUCCESS;
    685          		}
    686          #else
    687          		/*-------------------------------------------------------*/
    688          		/*以下代码检查数据包格式是否正确                      */
    689          		/*-------------------------------------------------------*/
    690          		if (g_resCmd.CmdPos == 1)
    691          		{
    692          			g_resCmd.DataLength = g_resCmd.CmdBuffer[0];
    693          			if (g_resCmd.DataLength == 0)
    694          			{
    695          				g_resCmd.CmdPos = 0;
    696          				g_resCmd.status = RES_UNKOWN_MSG;
    697          				return -1;
    698          			}
    699          		}
    700          
    701          		if (g_resCmd.CmdPos == 3)
    702          		{
    703          			if (g_resCmd.CmdBuffer[2] != 0)	//Message Source, must be 0 
    704          			{
    705          				g_resCmd.CmdPos = 0;
    706          				g_resCmd.status = RES_UNKOWN_MSG;
    707          				return -1;
    708          			}
    709          		}
    710          
    711          		if (g_resCmd.CmdPos == g_resCmd.DataLength+2)	//接收完成
    712          		{
    713          			checksum = calc_checksum(g_resCmd.CmdBuffer, g_resCmd.DataLength);
    714          			if (((checksum>>8)&0xFF) != g_resCmd.CmdBuffer[g_resCmd.DataLength] ||
    715          				 (checksum&0xFF) != g_resCmd.CmdBuffer[g_resCmd.DataLength+1]
    716          				)
    717          			{
    718          				g_resCmd.CmdPos = 0;
    719          				g_resCmd.status = RES_CHECKFAILURE;
    720          				return -1;
    721          			}
    722          			else
    723          			{
    724          				if (g_resCmd.CmdBuffer[1] == CMD_ACK)
    725          				{
    726          					g_resCmd.status = RESPONSE_ACK;
    727          				}
    728          				else if (g_resCmd.CmdBuffer[1] == CMD_NAK)
    729          				{
    730          					g_resCmd.status = RESPONSE_NAK;
    731          				}
    732          				else
    733          				{
    734          					g_resCmd.status	= RESPONSE_SUCCESS;
    735          				}
    736          			}
    737          		}
    738          		
    739          		if (g_resCmd.CmdPos > g_resCmd.DataLength+2)
    740          		{
    741          			reset_resVar();
    742          			g_resCmd.status = RES_UNKOWN_MSG;
    743          			return -1;
    744          		}
    745          #endif
    746          	return 0;
    747          }
    748          
    749          /*
    750          * @brief: host控制scanner的beep
    751          * @param[in] beep_code: 取值范围 0x00-0x19
    752          */
    753          void UE988_beep(unsigned char beep_code)
    754          {
    755          	unsigned char op_code = BEEP;
    756          	unsigned char status = 0x0;
    757          	unsigned char cmd_buf[2] = {0};
    758          
    759          	cmd_buf[0] = beep_code;
    760          	pack_command(op_code, status, cmd_buf, 1);
    761          	write_cmd_to_scanner(g_pReqCmd, 7);
    762          }
    763          
    764          /*
    765          * @brief: host控制scanner的LED
    766          * @param[in] ctrl_type: UE988_LED_OFF	1
    767          *						UE988_LED_ON	2
    768          */
    769          void UE988_led_ctrl(unsigned char ctrl_type)
    770          {
    771          	unsigned char led_select[2] = {0x01};
    772          
    773          	if (ctrl_type == UE988_LED_OFF)
    774          	{
    775          		pack_command(LED_OFF, 0, led_select, 1);
    776          	}
    777          	else if (ctrl_type == UE988_LED_ON)
    778          	{
    779          		pack_command(LED_ON, 0, led_select, 1);
    780          	}
    781          	else
    782          	{
    783          		return;
    784          	}
    785          
    786          	write_cmd_to_scanner(g_pReqCmd, 7);
    787          }
    788          
    789          /*
    790          * @brief: reset the decoders parameter settings to the factory default values
    791          */
    792          void UE988_reset_param(void)
    793          {
    794          	pack_command(PARAM_DEFAULTS, 0, 0, 0);
    795          	write_cmd_to_scanner(g_pReqCmd, 6);
    796          }
    797          
    798          /*
    799          * @brief: 获取decoder当前的参数信息
    800          * @param[in] param_num: 参数代号
    801          * @ret:		-1: 获取失败
    802          *			其它: 参数值
    803          */
    804          int UE988_get_curParam(unsigned char param_num)
    805          {
    806          	unsigned char req_data[2] = {0};
    807          
    808          	req_data[0] = param_num;
    809          	pack_command(PARAM_REQUEST, 0, req_data, 1);
    810          	g_ack_enable	= 0;	//the response to this command is PARAM_SEND, not ACK
    811          	write_cmd_to_scanner(g_pReqCmd, 7);
    812          
    813          	//wait response (PARAM_SEND)
    814          	reset_resVar();
    815          	StartDelay(400);			/* 延时2S		*/
    816          	while (DelayIsEnd() != 0)
    817          	{
    818          		if (g_resCmd.status == RESPONSE_SUCCESS) //成功收到响应
    819          		{
    820          			if (g_resCmd.CmdBuffer[1] != PARAM_SEND ||
    821          				g_resCmd.CmdBuffer[5] != param_num)	//响应数据错误
    822          			{
    823          				g_ack_enable	= 1;
    824          				OSTimeDlyHMSM(0,0,0,500);
    825          				send_nak_to_sanner(RES_UNKOWN_MSG);
    826          				return -1;
    827          			}
    828          			else
    829          			{
    830          				g_ack_enable	= 1;
    831          				OSTimeDlyHMSM(0,0,0,500);
    832          				send_ack_to_scanner();
    833          				return	g_resCmd.CmdBuffer[6];
    834          			}
    835          		}//成功收到响应
    836          		else if (g_resCmd.status == RESPONSE_NAK)	//响应失败
    837          		{
    838          			g_ack_enable	= 1;
    839          			return -1;
    840          		}
    841          		else if (g_resCmd.status == RES_CHECKFAILURE)
    842          		{
    843          			g_ack_enable	= 1;
    844          			OSTimeDlyHMSM(0,0,0,500);
    845          			send_nak_to_sanner(RES_CHECKFAILURE);
    846          			return -1;
    847          		}
    848          		else if (g_resCmd.status == RES_UNKOWN_MSG)
    849          		{
    850          			g_ack_enable	= 1;
    851          			OSTimeDlyHMSM(0,0,0,500);
    852          			send_nak_to_sanner(RES_UNKOWN_MSG);
    853          			return -1;
    854          		}
    855          	}//延时
    856          
    857          	//超时
    858          	g_ack_enable	= 1;
    859          	return -2;
    860          }
    861          
    862          /*
    863          * @brief: 设置decoder当前的参数信息
    864          * @param[in] param_num: 参数代号
    865          * @param[in] param_value: 参数值
    866          * @param[in] set_type: 设置方式 0: 暂时设置，断电后恢复到原值; 1: 永久设置
    867          * @ret:		-1: 设置失败
    868          *			0: 设置成功
    869          */
    870          int UE988_set_curParam(unsigned char param_num, unsigned char param_value, unsigned char set_type)
    871          {
    872          	unsigned char status;
    873          	unsigned char param_data[3] = {0};
    874          	int ret;
    875          
    876          	param_data[0] = 0xFF;	//Beep Code, ignore
    877          	param_data[1] = param_num;
    878          	param_data[2] = param_value;
    879          
    880          	status = (set_type == 0)? 0x0 : 0x08;
    881          
    882          	pack_command(PARAM_SEND, status, param_data, 3);
    883          	ret = write_cmd_to_scanner(g_pReqCmd, 9);
    884          
    885          	return ret;
    886          }
    887          
    888          /*
    889          * @brief: 控制decoder的扫描状态
    890          * @param[in] ctrl_type: UE988_SCAN_DISABLE  UE988_SCAN_ENABLE
    891          */
    892          void UE988_scan_ctrl(unsigned char ctrl_type)
    893          {
    894          	if (ctrl_type == UE988_SCAN_DISABLE)
    895          	{
    896          		pack_command(SCAN_DISABLE, 0, 0, 0);
    897          	}
    898          	else if (ctrl_type == UE988_SCAN_ENABLE)
    899          	{
    900          		pack_command(SCAN_ENABLE, 0, 0, 0);
    901          	}
    902          	else
    903          	{
    904          		return;
    905          	}
    906          
    907          	write_cmd_to_scanner(g_pReqCmd, 6);
    908          }
    909          
    910          /*
    911          * @brief: 进入休眠状态
    912          * @note:
    913          *	如果初始化模块时开启了低功耗模式，那么模块会自动进入低功耗，不需要调用此函数
    914          *	默认状态下，模块开启低功耗模块
    915          */
    916          void UE988_enter_sleep(void)
    917          {
    918          	pack_command(SLEEP, 0, 0, 0);
    919          	write_cmd_to_scanner(g_pReqCmd, 6);
    920          }
    921          
    922          /*
    923          * @brief: 唤醒模块
    924          */
    925          void UE988_wakeup(void)
    926          {
    927          	unsigned char cmd[2] = {0};
    928          
    929          	send_data_to_scanner(cmd, 1);
    930          
    931          	StartDelay(10);			/* 延时50ms		*/
    932          	while (DelayIsEnd() != 0)
    933          	{
    934          		;
    935          	}
    936          }
    937          
    938          /*
    939          * @breif:  开始 或 停止扫描条码
    940          * @param[in]: ctrl_type: UE988_START_DECODE  UE988_STOP_DECODE
    941          */
    942          void UE988_start_stop_decode(unsigned char ctrl_type)
    943          {
    944          	if (ctrl_type == UE988_START_DECODE)
    945          	{
    946          		pack_command(START_DECODE, 0, 0, 0);
    947          	}
    948          	else if (ctrl_type == UE988_STOP_DECODE)
    949          	{
    950          		pack_command(STOP_DECODE, 0, 0, 0);
    951          	}
    952          	else
    953          	{
    954          		return;
    955          	}
    956          
    957          	write_cmd_to_scanner(g_pReqCmd, 6);
    958          }
    959          
    960          /*
    961          * @breif:  获取条形码
    962          * @param[out]: unsigned char *code_type: 条形码类型		10个字节
    963          * @param[out]: unsigned char *code_buf: 存储条形码的缓存, code Type + decode data
    964          * @param[in]:  unsigned char inbuf_size: 传进来用来存放decode_data的buf大小
    965          * @param[out]  unsigned char *code_len:	 实际获取的条形码的长度，如果实际获取的长度比传进来的buf大，那么只返回传进来的buf大小的数据
    966          */
    967          int UE988_get_barcode(unsigned char *code_type, unsigned char *code_buf, unsigned char inbuf_size,unsigned char *code_len)
    968          {
    969          	unsigned char *code_name;
    970          	int		i = 0;
    971          
    972          	//scan_start = 1;
    973          	//enable scan
    974          #ifndef UE988_DEBUG
    975          	//UE988_scan_ctrl(UE988_SCAN_ENABLE);
    976          
    977          	//start decode
    978          	UE988_start_stop_decode(UE988_START_DECODE);
    979          #endif
    980          	//get code data
    981          	reset_resVar();
    982          	//StartDelay(800);			/* 延时4S		*/    //明德的扫描头的超时有4S
    983          	//for(i = 0; i < 48; i++)
    984              for(i = 0; i < wait_time_out; i++)   //新扫描头的超时只有3S左右
    985          	{
    986          		if (g_resCmd.status == RESPONSE_SUCCESS) //成功收到响应
    987          		{
    988          #ifdef UE988_DEBUG
    989          			*code_len = 20;
    990          			memcpy(code_buf,g_resCmd.CmdBuffer,20);
    991                      return 0;
    992          #else
    993          			send_ack_to_scanner();
    994          		
    995          			if (g_resCmd.CmdBuffer[1] == DECODE_DATA)
    996          			{
    997          				*code_len	= g_resCmd.CmdBuffer[0]-5;
    998          				memcpy(code_buf, &g_resCmd.CmdBuffer[5], ((*code_len > inbuf_size)?inbuf_size:*code_len));
    999          				code_name	= type2name(g_resCmd.CmdBuffer[4]);
   1000          				if ((code_name != 0)&&(code_type != 0))
   1001          				{
   1002          					strcpy(code_type, code_name);
   1003          				}
   1004          				//Beep(400);
   1005          				//scan_start = 0;
   1006          				return 0;
   1007          			}
   1008          #endif	                        
   1009          		
   1010          		}//成功收到响应
   1011          		else if (g_resCmd.status == RESPONSE_NAK)	//响应失败
   1012          		{
   1013          			//scan_start = 0;
   1014          			return -1;
   1015          		}
   1016          		else if (g_resCmd.status == RES_CHECKFAILURE)
   1017          		{
   1018          #ifndef UE988_DEBUG
   1019          			send_nak_to_sanner(RES_CHECKFAILURE);
   1020          #endif			
   1021          			//scan_start = 0;
   1022          			return -1;
   1023          		}
   1024          		else if (g_resCmd.status == RES_UNKOWN_MSG)
   1025          		{
   1026          #ifndef UE988_DEBUG
   1027          			send_nak_to_sanner(RES_UNKOWN_MSG);
   1028          #endif			
   1029          			//scan_start = 0;
   1030          			return -1;
   1031          		}
   1032          
   1033          		OSTimeDlyHMSM(0, 0, 0, 100);
   1034          	}//延时
   1035          
   1036          	//scan_start = 0;
   1037          	return -1;
   1038          }
   1039          
   1040          /*
   1041          * @brief: 获取 扫描头软件版本号
   1042          * @note unsigned char *softVer 20字节的缓冲区
   1043          */
   1044          int UE988_get_softVersion(unsigned char *softVer, unsigned char *plen)
   1045          {
   1046          	unsigned int cnt;
   1047          
   1048          	pack_command(REQUEST_REVISION, 0, 0, 0);
   1049          	g_ack_enable = 0;
   1050          	if(write_cmd_to_scanner(g_pReqCmd, 6))
   1051          	{
   1052                         g_ack_enable = 1;
   1053          		return -1;
   1054          	}
   1055          
   1056          	//wait response (PARAM_SEND)
   1057          	reset_resVar();
   1058          	cnt = 180;			/* 延时2S		*/
   1059          	while (cnt--)
   1060          	{
   1061          		if (g_resCmd.status == RESPONSE_SUCCESS) //成功收到响应
   1062          		{
   1063          			if (g_resCmd.CmdBuffer[1] != REPLY_REVISION)	//响应数据错误
   1064          			{
   1065          				send_nak_to_sanner(RES_UNKOWN_MSG);
   1066          				g_ack_enable = 1;
   1067                                          return -1;
   1068          			}
   1069          			else
   1070          			{
   1071          				send_ack_to_scanner();
   1072          				(*plen) = g_resCmd.CmdBuffer[0] - 4;
   1073          				memcpy(softVer, g_resCmd.CmdBuffer+4, ((*plen)>20)?20:(*plen));
   1074          				if(*plen > 20)
   1075          				{
   1076          					*plen = 20;
   1077          				}
   1078          				g_ack_enable = 1;
   1079          				return	0;
   1080          			}
   1081          		}//成功收到响应
   1082          		else if (g_resCmd.status == RESPONSE_NAK)	//响应失败
   1083          		{
   1084                            g_ack_enable = 1;
   1085          			return -1;
   1086          		}
   1087          		else if (g_resCmd.status == RES_CHECKFAILURE)
   1088          		{
   1089          			send_nak_to_sanner(RES_CHECKFAILURE);
   1090          			g_ack_enable = 1;
   1091                                  return -1;
   1092          		}
   1093          		else if (g_resCmd.status == RES_UNKOWN_MSG)
   1094          		{
   1095          			send_nak_to_sanner(RES_UNKOWN_MSG);
   1096          			g_ack_enable = 1;
   1097                                  return -1;
   1098          		}
   1099          
   1100          		//OSTimeDlyHMSM(0,0,0,10);
   1101                          Delay(5000);
   1102          	}//延时
   1103          
   1104          	//超时
   1105          	g_ack_enable = 1;
   1106                  return -1;
   1107          }
   1108          
   1109          
   1110          #if 0
   1111          void UE988_scan_task(void)
   1112          {
   1113          	unsigned char cur_key;
   1114          	unsigned char code_type[20];
   1115          	unsigned char code_len;
   1116          
   1117          	while (1)
   1118          	{
   1119          		memset(g_decode_data, 0, MAX_DECODE_DATA);
   1120          		if (UE988_get_barcode(code_type, g_decode_data, &code_len) == 0)
   1121          		{
   1122          			gui_TextOut(30, 178, &g_decode_data[0], 1);
   1123          			StartDelay(200);			/* 延时1S		*/
   1124          			while (DelayIsEnd() != 0)
   1125          			{}
   1126          		}
   1127          		cur_key = *keypad_getkey();
   1128          		if (cur_key != KEY_FUN1)
   1129          		{
   1130          			break;
   1131          		}
   1132          	}
   1133          
   1134          	gui_TextOut(30, 178, "                  ", 0);
   1135          }
   1136          #endif

   Maximum stack usage in bytes:

     Function                 .cstack
     --------                 -------
     UE988_GPIO_config            32
     UE988_Init                    8
     UE988_Init_param              8
     UE988_NVIC_config             8
     UE988_RxISRHandler            8
     UE988_beep                   16
     UE988_codeType_ctrl          16
     UE988_enter_sleep             8
     UE988_get_barcode            24
     UE988_get_curParam           16
     UE988_get_softVersion        16
     UE988_led_ctrl               16
     UE988_reset_param             8
     UE988_scan_ctrl               8
     UE988_set_codeParam          32
     UE988_set_curParam           16
     UE988_set_decoder_switch      8
     UE988_start_stop_decode       8
     UE988_wakeup                  8
     calc_checksum                 8
     memcpy                        8
     memset                        8
     pack_command                 32
     reset_resVar                  0
     send_ack_to_scanner           8
     send_data_to_scanner         16
     send_nak_to_sanner           16
     set_UE_param_default         16
     set_decode_data_format       24
     switch_to_Host_Mode          24
     type2name                     0
     write_cmd_to_scanner         16


   Section sizes:

     Function/Label                                 Bytes
     --------------                                 -----
     memcpy                                           14
     memset                                           20
     g_ack_enable                                      1
     g_resCmd                                         12
     g_pReqCmd                                         4
     host_ack                                          8
     wait_time_out                                     4
     scanner_baudrate                                  4
     code_type_name_tbl                              248
     UE988_codeType_ctrl                             148
     UE988_set_codeParam                             102
     type2name                                        56
     UE988_GPIO_config                               172
     UE988_NVIC_config                                58
     reset_resVar                                     26
     send_data_to_scanner                             56
     write_cmd_to_scanner                            102
     calc_checksum                                    38
     pack_command                                    172
     send_ack_to_scanner                              16
     send_nak_to_sanner                               52
     set_UE_param_default                             44
     switch_to_Host_Mode                             112
     set_decode_data_format                           88
     UE988_Init_param                                100
     UE988_set_decoder_switch                        336
     UE988_Init                                      124
     UE988_RxISRHandler                              332
     UE988_beep                                       42
     UE988_led_ctrl                                   68
     UE988_reset_param                                26
     UE988_get_curParam                              272
     UE988_set_curParam                               60
     UE988_scan_ctrl                                  54
     UE988_enter_sleep                                26
     UE988_wakeup                                     32
     UE988_start_stop_decode                          54
     UE988_get_barcode                               206
     UE988_get_softVersion                           264
     ??DataTable13                                     4
     ??DataTable79                                     4
     ??DataTable83                                     4
     ??DataTable84                                     4
     ??DataTable92                                     4
     ?<Constant "Code 39">                             8
     ?<Constant "Codabar">                             8
     ?<Constant "Code 128">                           12
     ?<Constant "Discrete 2">                         12
     ?<Constant "IATA 2">                              8
     ?<Constant "Interleaved 2 of 5">                 20
     ?<Constant "Code 93">                             8
     ?<Constant "UPC A">                               8
     ?<Constant "UPC A 2S">                           12
     ?<Constant "UPC A 5S">                           12
     ?<Constant "UPC E0">                              8
     ?<Constant "UPC E0 2S">                          12
     ?<Constant "UPC E0 5S">                          12
     ?<Constant "EAN 8">                               8
     ?<Constant "EAN 13">                              8
     ?<Constant "EAN 13 2S">                          12
     ?<Constant "EAN 13 5S">                          12
     ?<Constant "MSI">                                 4
     ?<Constant "EAN 128">                             8
     ?<Constant "UPC E1">                              8
     ?<Constant "UPC E1 2S">                          12
     ?<Constant "UPC E1 5S">                          12
     ?<Constant "Tp Code 39">                         12
     ?<Constant "RSS-Limit">                          12
     ?<Constant "RSS-14">                              8
     ?<Constant "RSS-Expanded">                       16
     ?<Constant "UK">                                  4
     ?<Constant "China Post">                         12
     ?<Constant "Code 11">                             8
     ?<Constant "Matrix 2 0f 5">                      16
     ?<Constant {0}>                                   8
     ?<Constant {0}>_1                                16
     ?<Constant {5, 209, 4, 0, 0, 0, 0}>               8
     ?<Constant {4, 216, 4, 0, 255, 32}>               8
     ?<Constant {7, 198, 4, 8, 0, 138, 8, 254, 149}   12
     ?<Constant {7, 198, 4, 8, 0, 238, 1, 254, 56}>   12
     ?<Constant "\026\001\027 ">                       8
     ?<Constant "\024\001\025 ">                       8
     ?<Constant "\a\306\004\b\0004\000\376\363">      12
     ?<Constant {0}>_2                                 2
     ?<Constant {1}>                                   2
     ?<Constant {0}>_3                                 2
     ?<Constant {0}>_4                                 4
     ?<Constant {0}>_5                                 2

 
    25 bytes in section .bss
   248 bytes in section .data
   424 bytes in section .rodata
 3 292 bytes in section .text
 
 3 258 bytes of CODE  memory (+ 34 bytes shared)
   424 bytes of CONST memory
   273 bytes of DATA  memory

Errors: none
Warnings: 11
